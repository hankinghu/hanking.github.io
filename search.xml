<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sdm]]></title>
    <url>%2F2018%2F04%2F20%2Fsdm%2F</url>
    <content type="text"><![CDATA[1.概述简要介绍：这篇文章主要提出了一种名为SDM（Supervised Descent Method）的方法，用来最小化非线性最小二乘（Non-linear Least Squares）目标函数，即目标函数是均方误差。SDM方法通过学习得到一系列下降的方向和该方向上的尺度，使得目标函数以非常快的速度收敛到最小值，回避了求解Jacobian矩阵和Hessian矩阵的问题。下面开始详细介绍，我补充了文章中只给出结果的推导过程，并且稍微调整了一下文章中牛顿步的推导过程。2.从牛顿步说起数值优化在很多领域都有很重要的应用，计算机视觉中很多重要的问题比如（行人跟踪、人脸对齐等）都可以化成非线性优化问题来解决。解决非线性优化的方法有很多，其中非常常用的有基于一阶的或者是二阶的优化方法，比如梯度下降方法、牛顿步、LM算法等等。尽管很多年过去了，在二阶导可求得情况下，牛顿步仍然被认为是一个非常优秀的算法。那么什么是牛顿步方法呢？下面简单介绍一下牛顿步，后面还会详细推导牛顿步。牛顿步：在Hessian矩阵正定的情况下，极小值可以通过求解线性方程组来迭代求解。给定一个初始的估计值x0∈Rp×1，牛顿步的更新迭代公式如下：xk+1=xk−H−1(xk)Jf(xk)(1) 其中H−1(xk)∈Rp×p是在xk点的Hessian矩阵,Jf(xk)∈Rp×1是 在xk点的 Jacobian矩阵。牛顿步方法有两个主要优点： 如果牛顿步可以收敛，那么它的收敛速度是二次的，收敛速度非常快。 如果初始点在最小点邻域附近，那么它一定可以收敛。但牛顿法在应用中，也有几个缺点： Hessian矩阵在极小值附近是局部正定的，但可能不是全局正定的，这就会导致牛顿步并不一定朝向下降的方向。 牛顿步需要函数二次可导。这个要求在实际应用中是一个很强的要求，比如图像处理中经常被使用的SIFT特征，它可以被看成是一个不可导的特征，因此在这种情况下，在我们只能通过数值逼近下降的方向或者是Hessian矩阵，但这种计算代价非常大。 由于Hessian矩阵通常很大，计算它的逆矩阵代价是非常大的，复杂度通常是O(p3)。以上三个缺陷使我们在实际应用中，很难计算精确的Hessian矩阵，甚至连数值逼近都是很困难的（由于计算代价比较大）。因此，该文章提出了SDM方法，用数据来学习下降的方向。下面两张图可以用来初步表示牛顿步和SDM两种方法的基本原理。3.人脸对齐的几个概念（简单介绍）在介绍SDM之前，还要先简单提一下人脸识别中人脸对齐的基本原理和相关的关键词，因为该SDM方法主要是在人脸对齐方面进行应用。人脸对齐（Face Alignment）基本原理：基本概念：人脸识别（face recognizaton）按顺序可以大体上分为四个部分，即人脸检测（face detection),人脸对齐（face alignment），人脸校验（face verification）和人脸识别（face identification）。 人脸检测就是在一张图片中找到人脸所处的位置，即将人脸圈出来，比如拍照时数码相机自动画出人脸。人脸对齐就是在已经检测到的人脸的基础上，自动找到人脸上的眼睛鼻子嘴和脸轮廓等标志性特征位置。人脸校验就是判断两张脸是不是同一个人。人脸识别就是给定一张脸，判断这张脸是谁。本文研究其中的第二部分，人脸对齐。人脸对齐中的几个关键词：形状（shape）：形状就是人脸上的有特征的位置，如下图所示，每张图中所有黄点构成的图形就是该人脸的形状。特征点（landmark）：形状由特征点组成，图中的每一个黄点就是一个特征点。人脸对齐的最终目的就是在已知的人脸方框（一般由人脸检测确定人脸的位置）上定位其准确地形状。人脸对齐的算法主要分为两大类：基于优化的方法（Optimization-based method）和基于回归的方法（Regression-based method）。SDM方法属于基于回归的方法。基于回归的方法的基本原理：对于一张给定的人脸，给出一个初始的形状，通过不断地迭代，将初始形状回归到接近甚至等于真实形状的位置。4.Supervised Descent Method给定一张含有m个像素的图片d∈Rm×1,d(x)∈Rp×1表示该图片上的p个特征点，h()表示一个非线性特征提取函数，比如h(d(x))∈R128p×1可以表示从p个特征点上提取出的SIFT特征，每个特征点提取出了128个SIFT特征。那么我们的目标就是，在给定一个初始形状x0的基础上，通过回归的方法，将x0回归到该人脸正确的形状x∗上，用数学的方式表达，即为求得使下面的f(x0+Δx)最小的Δx。f(x0+Δx)=||h(d(x0+Δx))−ϕ∗||22(2) 其中ϕ∗=h(d(x∗))表示该人脸的真实特征点所提取出的SIFT特征，当然，上面说的是在预测时我们的目标，在预测时我们只有初始的x0,而Δx和ϕ∗我们是不知道的。在训练时，我们是知道Δx和ϕ∗的，我们要在训练时训练得到一个良好的回归器，使它能够让初始的x0一步步回归到正确的未知的形状上去。一般来说初始的x0就是所有已知样本的真实形状的平均形状。示意图如下图所示。 那么问题来了，如果每一张脸的初始形状都是一样的（即都是已知样本的真实形状的平均形状），那么怎么让它们回归到各自人脸的真实形状呢，答案就是每张图片提取出的不同的SIFT特征（具体采用什么特征可以依据情况而定，论文中 采用了SIFT特征，但也可以采用如HOG，DOG，甚至LBF等特征）了，虽然采用了相同的初始形状，但在不同的图片上，相同的初始形状所提取出的SIFT特征是完全不同的，也就是ϕ0是不同的，这样就可以通过回归器将其回归到各自的真实形状上了。这一点通过上面的公式也能看出。现在我们已经有了优化的目标，就是要得到一个回归器，这个回归器能起到的作用是将一个初始形状回归到真实形状上去。也就是学到正确的回归器使其得到最好的Δx 。当然想要从初始形状一步步回归到真实形状，只学习一个Δx一般是不行的，因为一步就回归到最小点一般来说要求比较高，即使是牛顿步回归的比较快，通常也不能一步就达到目标。所以我们要学习得到多个不同的回归器，它们依次回归下来，能得到一系列的Δx,这样我们就能很快根据xk+1=xk+Δx得到使目标函数最小的点。下面从牛顿步开始引出SDM。首先再写一遍目标函数，如下：f(x0+Δx)=||h(d(x0+Δx))−ϕ∗||22(3) 我们使用的是从初始特征点周围提取的SIFT特征作为第一次回归的输入，然而SIFT算子是不可导的，所以如果想要使用一阶或者二阶方法来最小化上面的目标函数，那就只能用数值逼近的方法来估计Jacobian和Hessian矩阵（比如有限差分方法等）。然而数值估计计算量非常大，所以我们要采用SDM方法来学习下降的方向和下降的尺度，或者说学习Jaobian和Hessian矩阵。为了从牛顿步开始引出SDM，我们首先假设h()这个SIFT特征提取函数是二次可导的。这样才能计算Hessian矩阵。以下部分推导和论文不同，论文中只给了结论，我补充了论文没有写的推导过程。同时优化了一下牛顿步的推导过程。第一步，我们首先获得一个初始的形状x0,采用的方式是用所有训练样本的真实形状的平均形状给x0赋值，也就是说我们迭代的初值为:x0=1N∑Ni=1x∗i(4)接着就可以根据公式（3）计算f(x0)，即令Δx=0。现在我们已经有了f(x0),我们想要知道朝什么样的方向改变x0并且改变多少x0可以得到一个好的f(x1)，使f(x1)尽量接近全局最小值，这里f(x1)=f(x0+Δx)。我们在x0点对f(x)进行二阶泰勒展开，如下：f(x)=f(x0)+Jf(x0)T(x−x0)+12(x−x0)TH(x0)(x−x0)+o(|x−x0|2)(5) 等式最右边一项是高阶项，可以忽略。也就是说，我们要优化的目标，就是下面这个二次型，我们要极小化下面的二次型：f(x)=f(x0)+Jf(x0)T(x−x0)+12(x−x0)TH(x0)(x−x0)(6) 因为要极小化f(x)，所以我们要对x进行求导，并且令导数等于0，以此来求出优化的方向和大小，下面对每一项进行求导：df(x)dx=∇f(x)(7) df(x0)dx=0(8) dJf(x0)T(x−x0)dx=Jf(x0)(9) d12(x−x0)TH(x0)(x−x0)dx=12H(x0)+H(x0)T=H(x0)(x−x0)(10) 因此，求导后得到：∇f(x)=0+Jf(x0)+H(x0)(x−x0)(11) 令导数等于0，得：∇f(x)=Jf(x0)+H(x0)(x−x0)=0(12) 可以解得：x=x0−H−1(x0)Jf(x0)(13) 即x1=x0−H−1(x0)Jf(x0)(14) 这即得到牛顿步的表达式。我们的第一次迭代的步长用牛顿步的方法求解就是：Δx1=−H−1(x0)Jf(x0)(15) 如果在目标函数二次可导的情况下，一直使用牛顿步计算出Δx2、Δx3、…、Δxk，那么可以根据更新表达式（如下）一直计算得到新的x，直到得到最优解。xk+1=xk+Δxk(16) 不过使用牛顿步计算几个Δx就要算几次Jacobian和Hessian矩阵，计算量之大可想而知了，况且目标函数还不一定二次可导（之前的二次可导是我们假设的，现在我们将去掉二次可导这个约束条件）。下面开始推导得到我们要的SDM的方法，是接着上面牛顿步的推导而来的：首先引入矩阵的链式求导法则如下：df(g(x))dx=dgT(x)dxdf(g)dg(17) 应用矩阵的链式求导法则：Jf(x0)=df(x)dx|x=x0=d||h(d(x))−ϕ∗||22dx|x=x0=d(ϕx−ϕ∗)Tdx|x=x0⋅d||ϕx−ϕ∗||22d(ϕx−ϕ∗)|x=x0 (18) 其中：d(ϕx−ϕ∗)Tdx|x=x0=dϕTxdx|x=x0=dhT(d(x))dx|x=x0=JTh(x0)(19) d||ϕx−ϕ∗||22d(ϕx−ϕ∗)|x=x0=d[(ϕx−ϕ∗)T(ϕx−ϕ∗)]d(ϕx−ϕ∗)|x=x0=2(ϕx−ϕ∗)|x=x0=2(ϕ0−ϕ∗)(20) 所以：Jf(x0)=2JTh(x0)(ϕ0−ϕ∗)(21) 因此x=x0−H−1(x0)Jf(x0)=x0−2H−1(x0)JTh(x0)(ϕ0−ϕ∗)(22) 所以我们的SDM方法的Δx1为：Δx1=−2H−1(x0)JTh(x0)(ϕ0−ϕ∗)(23) 看起来好像和牛顿步的Δx1=−H−1(x0)Jf(x0)区别不大，然而接下来就会看到区别：Δx1=−2H−1(x0)JTh(x0)(ϕ0−ϕ∗)=Δx1=−2H−1(x0)JTh(x0)ϕ0−2H−1(x0)JTh(x0)ϕ∗ (24) 设R0=−2H−1(x0)JTh(x0)，b0=−2H−1(x0)JTh(x0)ϕ∗,可将上式表示成:Δx1=R0ϕ0+b0(25) 也就是说，第一次增量Δx1变成了特征ϕ0的一次函数，而我们只需要知道R0和b0就可以直接算出第一次的增量Δx1！！！也许有人会问，但是根据你前面的公式，你的R0和b0也是在计算Jacobian和Hessian矩阵的基础上计算出来的啊，说的没错，但既然现在已经将目标Δx1写成了ϕ0的一次函数，我们计算的R0和b0难道还要绕回去算Jacobian和Hessian矩阵么，当然不可能了，我们只需要用我们最常用的方法，最小二乘即可！！即最小化下面这个目标函数：loss=||Δx1−R0ϕ0−b0||22(26) 此时可以由最小二乘的公式直接得到R0和b0，这里就不写了。得到了R0和b0,也就可以依法得到R1、b1、…、Rk和bk，也就可以算出对应的的Δx2、…、Δxk+1，这些Δx就是我们要的每一次的x的变化方向和变化的尺度，也是根据更新公式更新，直到得到最小点的x。有了R1、b1、…、Rk和bk，在测试样本进行回归的时候，就可以直接进行回归。下图是作者做的对比试验（控制的变量是特征提取函数h()不同）：有图可见，SDM的收敛速度比牛顿步更快，只是收敛得最终结果并没有达到最优（比牛顿步差一点），但SDM更具鲁棒性，在函数的Hessian矩阵不是正定的时候，SDM也能很快收敛。 做个总结：SDM方法在更新x时，就是将更新的增量Δx的计算方法进行了改变，由牛顿步的计算Jacobian和Hessian矩阵来得到增量Δx，变成了计算Rk和bk来得到增量Δx,通过推导将每一次的增量Δx变成了该次输入的特征ϕ的一次函数，并通过最小二乘直接计算一次函数的系数Rk和bk，大大减少了计算量。]]></content>
      <categories>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头号玩家]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%A4%B4%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[《头号玩家》是由史蒂文·斯皮尔伯格执导，扎克·佩恩、恩斯特·克莱恩编剧，泰伊·谢里丹、奥利维亚·库克、西蒙·佩吉、本·门德尔森、马克·里朗斯、T·J·米勒主演的科幻冒险片，于2018年3月30日在中国内地与北美同步上映。该片根据恩斯特·克莱恩同名小说改编，讲述了一个现实生活中无所寄托、沉迷游戏的大男孩，凭着对虚拟游戏设计者的深入剖析，历经磨难，找到隐藏在关卡里的三把钥匙，成功通关游戏，并且还收获了网恋女友的故事。 1 “它是斯皮尔伯格送给ACG爱好者/玩家们的一封情书。” 上面这句话从哪来的，已经不好考证了，因为它充斥在公众号、微博等各种关于《头号玩家》的评论中。 大家用这种饱含感情的方式，表达着对这部电影的欣赏和感激。 后来，关于该电影的各种彩蛋考据也都出来了，人们一边感叹着电子游戏文化的渊源历史，一边赞颂着斯导的用心良苦。 不过，这些被称为“彩蛋”的大量的细节，真正曾存在于国内观众童年时光中的，其实并不多。 甚至片中最后的重头戏中，与哥斯拉最终决战的“钢铁巨人”，对许多中国观众来说也略显陌生。如果没有媒体和一些资深爱好者们的分析，很多观众不管如何细致地观察，恐怕也会跟他们擦肩而过。 这并不难理解，就像美国人童年回忆中从没有过水浒卡和发条青蛙。所以照理说，中国观众的观影体验，应该是相对打了折扣的。但事实却并非如此。事实上，这个分数曾经还一度达到了9.2，并维持了很长时间。只是到了今天，它又稍稍回落了。这也恰巧印证了我在看这部电影之前听到一些声音，说：这个电影，最好趁这几天最热，尽早看。因为第一时间去看的，都是同道中人，在影院什么时候会欢呼什么时候会鼓掌，大家都有默契，会有一种“我们是一路人”的感觉。这样的话语，活像是一群忠实的信徒，在做一次虔诚的朝拜。与之相似的，还有看完电影时朋友的评价：“看到高达出来的那一刻，我都快哭了。”你说他好端端的，干啥哭呢。 是斯皮尔伯格巧夺天工的铺垫，还是对今天发达的3DCG技术的惊叹？也许，只是因为国内ACG用户对认同的渴求，太过强烈了。 2这样的“小题大做”，似乎很容易发生在国内网友身上。 2017年我们经历了一个类似的场景。当时我们去日本参加“初音未来：魔法未来演唱会”。 在前一天的中国粉丝聚会上，大家表现得还都相对比较平静。但在演唱会现场，当看到MIKU出现在眼前的那一刻，许多中国观众的眼中开始泛起泪光…… 直到演唱会散场，他们有的依然停在原地泣不成声，有的孤独的躲在角落默默的擦着眼泪，就好像平生的夙愿终于满足了一样。 结合这一幕，你或许能更深地体会前面说的—— “什么时候会欢呼什么时候会鼓掌，大家都有默契，会有一种“我们是一路人”的感觉。”——是多么的可贵了。 至于当时现场的日本观众——只是像参加任何一个普通的演唱会一样，平平常常地回家了。在他们眼中，这样的活动不是挺常见的么？ 就像这次的《头号玩家》。 这部以电子游戏为主题的电影，大前提当然是建立在“对游戏文化的认可”上的，对国外观众来说，这似乎是一个心照不宣的背景。 影片不仅没有过度偏袒游戏，还从各个角度告诉观众，不要一味地沉迷虚拟世界，也应适时地回归，感受现实世界的美好。 喧扰到最后归于平淡，是斯氏电影所用的一贯手段。 3然而，这所谓的平淡，在国内玩家看来，已经是可以想象到的最美好的画面。 就在父辈沉迷手机的几年之前，网瘾还一直被当做精神疾病，需要像精神病人一样被剥夺人身自由。 如今，事态看似已经有所好转，但批判的口径也不过是把矛头从玩游戏的人转向了游戏本身。 直到现在的种种讯号依然标明，电子游戏还处在被“一棒打死”的边缘。 或许是出于一种“受创应激反应”，现在的玩家们以及各种游戏媒体（包括我们），也会常常把一些父子玩游戏增强亲子关系，生病后靠游戏感受到人间温暖云云的故事，当成什么不得了的新闻分享给大家。 像是互舔伤口似的寻求着心灵的些许慰藉。 但，“游戏”这个载体本来就有这样的功能啊，看到它被正确的使用，我们又为何如此的兴奋呢。 惊弓之鸟们又何尝不清楚这个道理。 4在这个谁嗓门高谁就能占据舆论主动权的时代，总是少不了那些大嗓门的“主流“声音。 即使是这次的《头号玩家》。 影片上映的第二天，澎湃新闻就发表了文章： “《头号玩家》：斯皮尔伯格的亚文化,年轻人接受吗”可见“游戏”这个东西负能量之强大，就算斯皮尔伯格敢于染指也会被拉向被鄙视的一端。 更不用说那些深陷其中的玩家了。 这篇文章的最后还说到： “年轻人的亚文化，本来就是用来将其他人排除在外的。”但我总觉得，所谓的“年轻人”并不是不想让你进去，而是在全力地守护自己最后一片热土，你总不能把抱团取暖也当做壁垒高筑。 虽然我们从来没有获得过应有的尊重，但并不代表不能在有人替我们向全世界呐喊的时候响起掌声： “看到了吧，我们喜欢的东西也有如此迷人的一面。”即使从来不奢求能有什么主流声音的认可的我们，也至少有足够的权利热泪盈眶。 5在知乎关于《头号玩家》的评价问题中，点赞最高的不是什么长篇大论的分析，而是一份简单的诉说，只是字里行间透着玩家群体特有的卑微甚至悲壮：相比平时描述电影如何精彩、如何打动人心，许多朋友对《头号玩家》并没有用什么优美的词语渲染，有些仅仅留下简单的： “去二刷”。那种情形，颇像是黑夜中冻得瑟瑟发抖的卖火柴的小女孩，在看到第一根火柴炫耀的光芒后，又急迫地去划第二根：哧！火苗又窜了出来，发出亮亮的光。墙被照亮了，变得透明了，她仿佛看见了房间里的东西： 当她说出喜欢玩游戏的时候，语气中不再带着卑微，亲戚们饶有兴致地问，听说玩游戏挺有意思的，能不能教教他们。她又擦了一根，哧！ 电视新闻上说：没想到在这个时代，还有家长把自己的管教无方归咎为游戏。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程--深入理解volatile关键字]]></title>
    <url>%2F2018%2F04%2F16%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[前言一个月以前就准备写篇关于volatile关键字的博客，一直没有动笔，期间看了大量的文章，发现一个小小volatile关键字竟然涉及JMM（Java memory model），JVM（Java virtual machine），Java多线程同步与安全各个方面的知识，写起了非常的困难，后面附带的参考文献仅仅是我看过文献的一部分。 Java memory model（Java内存模型）在讲volatile关键字之前必须先了解一下Java内存模型，如果不了解Java内存模型volatile关键字无从讲起。先看看下面的图。 由上图可以看出来，在JMM中内存分为两部分一个是Main Memory（主内存）另一个是Working Memory（工作内存）。 Main Memory（主内存）：主要存放Variable，此处的变量（Variable）与Java编程中所说的变量有所区别，它包括了实例字段、 静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。 Working Memory（工作内存）：每条线程还有自己的工作内存（Working Memory，可与处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、 主内存、 工作内存三者的交互关系如下图所示。 也就是说Java每条线程所拥有的工作内存通过，sava和load指令与主内存进行交互。另外还需要了解的一点是：Java的一切指令操作都是基于栈的（stack），因此工作内存中又包含以下两个部分： ①操作数栈（Operand Stack）对应上图左边的stack，也常称为操作栈，它是一个后入先出栈。 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。 例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。 举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。 ②局部变量表（Local Variable Table）对应上图右边的variable是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。 关于JMM（Java内存模型）部分，只需要了解这么多。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、 如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、 不可再分的。 ① lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 ②unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 ③read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 ④load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 ⑤use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 ⑥assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 ⑦store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 ⑧write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。 注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。 也就是说，read与load之间、 store与write之间是可插入其他指令的，如对主内存中的变量a、 b进行访问时，一种可能出现顺序是read a、read b、load b、load a 关于内存间交互操作的更多细节请参考深入理解Java虚拟机第二版（393页）。 并发原则①原子性（Atomicity）：原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。由Java内存模型来直接保证的原子性变量操作包括read、 load、assign、 use、 store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。 ②可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 ③有序性（Ordering）：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。 前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 Java Volatile Keyword先看一段英文解释： The Java volatile keyword is used to mark a Java variable as “being stored in main memory”. More precisely that means, that every read of a volatile variable will be read from the computer’s main memory, and not from the CPU cache（working memory）, and that every write to a volatile variable will be written to main memory, and not just to the CPU cache（working memory）. 简单对上面的这段话做两点说明：①线程读取一个被volatile修饰的变量时直接从main memory（主内存）中读取，而不是从working memory中读取。②线程写对一个volatile变量进行写操作时，直接写入到main memory（主内存）中，而不仅仅是写到working memory中。 volatile确保可见性先看下面的一个实例： 123456789101112131415161718192021private static boolean stop = false; public static void main(String[] args) &#123; //线程1 new Thread()&#123; @Override public void run() &#123; while(!stop) System.out.println(&quot;is not stop!&quot;); &#125; &#125;.start(); //线程2 new Thread()&#123; @Override public void run() &#123; stop=true; &#125; &#125;.start(); &#125; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么线程1读取到的就是最新的正确的值。 volatile确保有序性在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 volatile不能保证原子性为了说明volatile不保证原子性先举一个经典的例子，这个例子来自于深入理解Java虚拟机第二版（395页） 12345678910111213141516171819202122232425262728293031323334public class VolatileTest&#123; public static volatile int race=0； public static void increase（）&#123; race++； &#125; private static final int THREADS_COUNT=20； public static void main（String[]args）&#123; Thread[]threads=new Thread[THREADS_COUNT]； for（int i=0；i＜THREADS_COUNT；i++）&#123; threads[i]=new Thread（new Runnable（）&#123; @Override public void run（）&#123; for（int i=0；i＜10000；i++）&#123; increase（）； &#125; &#125; ）； threads[i].start（）； &#125; //等待所有累加线程都结束 while（Thread.activeCount（）＞1） Thread.yield（）； System.out.println（race）； &#125;&#125; 这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。 读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。先来看看上面代码中increase（）方法的字节码，然后对照着JMM来分析一下为什么会出现上面程序运行的结果。 1234567891011public static void increase（）；Code：Stack=2，Locals=0，Args_size=00：getstatic#13；//从主存中直接获取race的值放入到操作栈中。3：iconst_1 //将常数1放入操作栈中，4：iadd //获取操作栈中的两个值相加5：putstatic#13；//将操作栈中的race的值直接放入到主存中。8：returnLineNumberTable：line 14：0line 15：8 对于上面的字节码，给出一个运行图： 将Race=1放入到stack中，将常量1放入到stack中： 将stack中的两个数相加，并将结果放回到Main Memory中： 有上面的过程图可知，当执行将Race=1放入到stack中，将常量1放入到stack中时，其他线程可能抢占jvm此时还未执行后面的加法操作，比如说两个线程同时执行了前面的两步，将race=1放到了stack中，然后又执行加操作，此时虽然执行了两次加操作，race的值却是2，所以综合可知volatile并不能保证原子性。 参考文献深入理解Java虚拟机第二版http://www.cnblogs.com/dolphin0520/p/3920373.htmlhttp://jeremymanson.blogspot.sg/2008/11/what-volatile-means-in-java.htmlhttps://stackoverflow.com/questions/4885570/what-does-volatile-mean-in-javahttp://tutorials.jenkov.com/java-concurrency/volatile.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>Java并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书感想]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言 自从9月份开始找工作，已经很长时间没有写博客了。最近对文化大革命特别感兴趣，看了一些关于文革的书籍，如季羡林的《牛棚杂忆》，梁晓声的《一个红卫兵的自白》，余华的《兄弟》，杨显惠的命运三部曲《夹边沟记事》、《定西孤儿院纪事》、《甘南纪事》，傅高义的《邓小平时代》，刘少奇的《刘少奇日记》，罗斯·特里尔的《毛泽东传》，以及王大宾的《王大宾回忆录》终于对文化大革命的起因有了更加详细的了解。 文化大革命的原因发生在20世纪60年代中国大陆的文化大革命，实质上是毛泽东发动群众、介入中国共产党党内斗争的一场政治运动。反思这场文革运动，不只要研究毛泽东为何发动文革运动、为何能够发动这场文革运动，还要研究毛泽东怎样审时度势，发动和领导这场文革运动的，他的战略目标、战略部署，大势的掌控，主动进攻，被动应对，策略转换等等。总之，你不把毛泽东的想法、做法搞懂、搞清楚、搞明白，你对文革运动的反思，你对文革运动的回忆，往往就容易失实，失之于偏。这也是认识论的观点，只有理解了的东西才能更深刻地感觉它。 毛泽东发动文革运动的战略目标，是要打碎刘少奇掌控一线所建立与运作的权力系统，毛泽东要重回一线重建他能亲自掌控与运作的新的权力系统，在过程中发现和培养坚持执行毛泽东主张的社会主义路线的接班人，保证其社会主义路线的传承。毛泽东认为，他的这个战略目标，已不能用依合法程序的会议政变形式实现，必须借助群众运动的力量。由此，毛泽东在完成发动文革运动的准备，制定和发出“5•16通知”，启动文革运动后十年，有三个不同的战略运作阶段：1966年5月16日至1967年1月，为破坏旧秩序，打碎刘少奇掌控一线所建立与运作的权力系统阶段；1967年1月至1969年4月九大召开，为建立新秩序，以三结合的革命委员会形式，重建新的权力系统的阶段；1969年4月至1976年9月，为巩固通过文革运动所建立的新秩序阶段。《王大宾回忆录》根据这个认识，回忆和反思了他的文革运动经历。王大宾是北京地质学院的学生。北京地质学院文革运动中成立的群众组织“东方红公社”，以及由它发起和为头成立的“首都大专院校红卫兵革命造反总司令部”（简称“首都三司”），成为文革运动破坏旧秩序阶段反工作组造反派的旗帜、破坏旧秩序的先锋队。1967年3月5日，取代朱成昭成为地院东方红一把手的王大宾，后亦被毛泽东美誉为北京五大学生领袖之一。 1966年，北京59个大专院校，北大、清华、地院，在文革运动发动、动员群众破坏旧秩序阶段，在不同时段分别起了带头与示范作用。而抓典型引路正是毛泽东一贯的工作方法。 “5•16通知”下发后，毛泽东在捕捉发动群众的突破口。5月23日，吴传启等人在中国科学院哲学社会科学部（简称“学部”），贴出了批判原北京市委宣传部长、时任学部副主任兼政治部主任杨述的大字报，但并不具有动员群众的典型作用。5月25日，聂元梓等7人在北京大学贴出了批评宋硕、陆平、彭珮云的大字报。毛泽东得知后，立即批示在中央人民广播电台广播。果如所料，一石激起千重浪，全国沸腾，学校师生对学校党委领导批判造反的热情高涨。因北大四清运动，以聂元梓等人为代表的四清运动的积极分子，与彭真支持的陆平为首的校党委早已处在严重分歧与对立冲突中。打压他们的彭真，在“5.16通知”传达时已被点名批判，给了聂元梓等人勇气和批判方向。对北大四清运动的情况、分歧与冲突，毛泽东应早已知晓。张恩慈关于这方面的意见函毛泽东已有批示。北京大学的地位与影响不言而喻。聂元梓等7人的大字报被誉为第一张马列主义大字报，在文革运动破坏旧秩序阶段，作为发动群众投入文革运动的第一把火，其作用与影响确是历史的事实。 毛泽东欲擒故纵。刘少奇误判文革运动，采取派工作组的方式搞了一场“反右派”运动（有的工作组称为“抓游鱼”等），他还派王光美做清华工作组的顾问——实际上让她掌控清华工作组，介入清华文革运动，意欲再创一个类似四清“桃园经验”的“清华经验”。王光美在清华五十天，指导工作组打压反对工作组的学生和教师，结果搞出七八百名右派，其典型人物就是蒯大富，所以当时清华的右派也被称为“蒯派”。清华这次“反右派”运动成了1966年8月1日召开的八届十一中全会上压倒刘少奇的最顕着的一根稻草。毛泽东决定，刘少奇不再主持中央一线工作，决定撤出领导文革运动的工作组，让群众自己解放自己。1966年8月1日，毛泽东给清华大学附属中学的红卫兵写信，表示对红卫兵“说明对反动派造反有理”大字报的“热烈支持”。中国大陆的人民群众，自此在文革运动前期有了毛泽东领导下的结社自由。毛泽东更在1966年8月18日，穿上绿军装，戴上北京师范大学附属女子中学红卫兵、宋任穷女儿宋彬彬献上的红卫兵袖章，在天安门城楼检阅了来自全国各地的百万革命群众，公开表达了对红卫兵造反的支持。蒯大富对抗王光美主导的工作组个案，清华大学的地位与影响，无疑是毛泽东打破刘少奇一线主导的旧秩序的利器。 八届十一中全会后，周恩来、陶铸在文革运动的前线主持中央日常工作。文革运动出现了延续工作组路线的保工作组保守派群众组织，与反工作组的造反派群众组织的严重分歧与对立。在文革运动的这一时段，被薄一波“6•22批示”打压、视为“右派”的北京地质学院的少数师生，以平民子弟为主体，在1966年8月17日成立的北京地质学院东方红公社，以其鲜明、激进的反工作组路线的造反方向，第一个组织带领上千人的队伍，到地质部机关上访请愿的造反行动，震动京城，亦惊动了毛泽东。毛泽东与江青的女儿肖力，随时了解与掌握了这一时段地院文革运动的情况、态势。9月6日，联合北京高校反工作组造反派群众组织，以地院东方红为头的“首都三司”成立。“首都三司”代表的反工作组造反派组织，成立之初虽然处于少数派地位，但它符合毛泽东的战略部署，代表在文革运动第一阶段动员群众破坏旧秩序的造反大方向。经过1966年8月、9月的大字报、大鸣、大放、大辩论，保工作组的保守派群众组织与反工作组的造反派群众组织，已阵线分明，发展到互不兼容、激烈对抗的局面。1966年9月23日，地院东方红与保守派组织斗批改兵团，为争夺学院广播台的控制权发生的肢体冲突，被视为文革运动中发生在北京高校的第一次武斗事件。时任北京新市委第二书记吴德，根据周总理的指示，首先赶到北京地院处理这一事件。但吴德依据周总理的指示不能平息事件，无法摆平双方的对立冲突。吴德说：“这是周总理的指示，但他们根本不听。”随后中央文革组长陈伯达亦派关锋、戚本禹到地院处理这一事件。 在地院现场，吴德向戚本禹传达周总理指示后，戚本禹说：“这个办法不行，你们要支持‘东方红’，他们是左派，中央文革小组支持他们。”随后有林彪1966年国庆讲话，《红旗》十三期社论发表，十月中央工作会议召开，掀起全国性的批判资产阶级反动路线运动高潮。保守派组织迅速瓦解，反工作组造反派迅速发展壮大，成为多数派。依靠发展左派队伍，瓦解保守派组织，团结大多数群众，向刘少奇掌控一线建立与运作的权力系统造反，成为当时毛泽东处理文革运动中分裂与对立的各派群众组织的方针、政策。地院东方红也随之成为这一时段北京高校文革运动中造反冲杀出来的新典型、新领头羊。王大宾代表地院东方红，被毛泽东视为北京五大学生领袖之一，是真实反映了地院东方红、“首都三司”在文革运动破坏旧秩序阶段中的地位与影响的。《王大宾回忆录》记述的这一史实，值得研究者进一步深入展开，以更完整地还原文革运动历史的真相。 在许多记述北京文革运动的书中、文章中，都会拿北京高校造反派组织1967年后所谓“天派”、“地派”之分，所谓“天派”与“地派”的斗争说事。据我了解，被视为“天派”代表人物之一的北航红旗负责人韩爱晶，与视为“地派”代表人物之一的地院东方红负责人王大宾，他们都不承认北京有因一个焦点矛盾而对立分裂的有组织的天派、地派。《王大宾回忆录》中对这一认识表述了他的观点。我认为是符合当年北京高校文革运动真实情况的。 1967年，文革运动已进入毛泽东建立新秩序的新阶段。争夺在新秩序、新的权力系统中的地位与影响，主要表现为军队、干部与群众组织三者之间的博弈。分歧、冲突、对立已不像第一阶段那样两军对垒，阵线分明，左派、保守派已难以认定判断。毛泽东为了实现第二阶段建立新秩序、建立新的权力系统的战略目标，必须面对现实，权衡利弊。面对周恩来支持的老帅，副总理们在1967年2月，代表干部群体表达的强烈不满情绪，虽大为震怒，亦不能不最后妥协，示出团结的善意，并发社论宣示正确对待干部的方针。还发表《红旗》评论员文章，将打击干部一大片的过错，加之于刘少奇代表的资产阶级反动路线。面对武汉群众组织百万雄师在军队支持下，表现出对王力公开讲话宣布、而实为毛泽东所决定的处理武汉问题方针的激烈反抗，毛泽东决定改变过往处理文革运动中分裂与对立的各派群众组织、依靠发展左派队伍团结大多数群众的方针，以工人阶级内部没有根本的利害冲突的平等大联合的方针取而代之。毛泽东同时批判了“揪军内一小撮”斗争方向，果断处理了王力、关锋等人，稳定化解了军队的不满情绪。当年，王大宾对毛泽东文革运动战略阶段与战略方针、部署的转换，是认识不清楚的，头脑膨胀、犯错误是必然的。毛泽东1968年7月28日召见“五大学生领袖”谈话中，批评造反派组织多中心即无中心表现，认定山头林立的众多造反派组织，已发展到谁的话也不听，实已成为了建立新秩序的阻碍，起了破坏作用。《王大宾回忆录》正是依据这样的认识，反思1967年后，北京高校反工作组造反派组织之间发生的个别冲突事件，反思地院东方红与北大新北大公社之间1967年4月发生的民族文化宫展览问题上的冲突。王大宾后来主张东方红应专注学院运动，不要介入外单位运动的想法应是好的，但在当时的形势下，他亦骑虎难下，无法掌控。王大宾对毛泽东1968年7月28日，召见他们五大学生领袖的谈话有他自己的反思，也认识到文革运动的实践证明自己不行，最终被毛泽东“不要”是必然的。对此，回忆录中有较为明白的理解与评述，亦值得亲历过文革运动那段历史的人们和研究者深思。 以孔丹为头的“西纠”在成立之初，即在地院东方红到地质部机关上访请愿时，就彼此发生严重的对立与冲突。事过近50年，孔丹在回忆录《难得本色任天然》中，表明他们这些老红卫兵，“和老干部有着天然的联系”的人，与地院东方红王大宾这样的反工作组造反派，“具有本质的区别”。王大宾在回忆录中批评了孔丹的这一说法，认为其骨子里还是根深蒂固的“老子英雄儿好汉”的血统论，左右他的思维与判断。不知孔丹能否接受对他的这一思想的评说与批评。因为他在书中表白，当年他是不同意“老子英雄儿好汉，老子反动儿混蛋”这一狂热鼓吹封建血统论的对联的。 然而，孔丹的认识与想法，可以影响到上层的政策，区别对待处理同样参与文革运动同样事件的人。《王大宾回忆录》记述了他为何取代朱成昭，由二把手变成了地院东方红的一把手。叶剑英对文革运动的态度，如何通过其女儿叶向真影响到朱成昭，成为他从听从中央文革转向对它的怀疑、批评的主要动因。叶向真与朱成昭等人，后虽同被打成“叶、朱反革命集团”，关进监狱，但终局却有完全不同的人生命运与结局！王大宾感慨评说：“有人对《西游记》的评论说得好：有背景的妖怪都被收走了，没有背景的妖怪就被孙悟空打死了！” 王大宾对朱成昭人生命运的感慨，亦是对自己人生命运的感叹。文革运动中，能打上王大宾个人印记的大事件，应只有奉命参与并负责把彭德怀元帅从成都揪回北京这件事了。《回忆录》详述了王大宾参与这一事件的过程与细节，澄清了过往许多书籍文章关于这件事的不实、不全的描述，还原了历史真相，是《王大宾回忆录》的一大看点。在这一事件中，王大宾一方面在与彭德怀的接触交谈中，同情彭德怀的处境，并在认识上产生共鸣，为此不同意中央揪彭决定，派人到北京向中央文革小组汇报，申述他们的意见，但却遭到批评；另一方面，最终执行了周恩来和中央文革小组的指示，和成都军区派出干部一起，负责带领地院东方红的战士，把彭德怀安全护送到了北京。这两方面的事实，都是当年的客观存在，王大宾不能否定，他也从未否定。但令王大宾不理解的是，出于政治的需要，可以对同时存在的客观事实，选择性地认定、采信，并据此作出惩罚。在巩固文革运动新秩序的阶段，曾经发动了清查“5•16分子”的运动，王大宾被认定为同情彭德怀，抗拒执行中央从成都揪回彭德怀的决定，据此指控为王大宾的主要罪行，将其打成“5•16分子”，未经任何法律程序，剥夺王大宾的人身自由，关押审查四年之久。而至文革运动结束后的1978年，又将王大宾逮捕关押五年，至1983年8月18日，根据陈云“怎么只判天派？地派也要判！”的指示，武汉市中级人民法院作出刑事判决，指控“王大宾在一九六六年十二月至一九六八年八月期间，积极追随林彪、江青反革命集团进行犯罪活动”，王大宾被认定的主要“罪行”，就是王大宾带领地院部分学生，将彭德怀挟持，押到北京，“使彭德怀同志人身遭到迫害”。为此，王大宾被判处有期徒刑九年，剥夺政治权利三年。面对完全不适用1979年7月6日颁布、1980年1月11日生效实施的《中华人民共和国刑法》相关规定的审判，王大宾只能感叹：“当时的我能说什么呢？这就是政治。”]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>季羡林</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议面试知识点总结]]></title>
    <url>%2F2017%2F09%2F03%2Fhttp%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近在看面经的时候，发现大部分的公司面试的时候都会问到http协议，大部分的博客写的不是很系统，所以决定自己写一篇。 统一资源定位符URL在说HTTP协议之前必须要先了解URL（统一资源定位符）统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议://授权/路径?查询”。完整的、带有授权部分的普通统一资源标志符语法看上去如下：协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 第一部分 模式/协议（scheme）：它告诉浏览器如何处理将要打开的文件。最常用的模式是超文本传输协议（Hypertext Transfer Protocol，缩写为HTTP），这个协议可以用来访问网络。其他协议如下： http——超文本传输协议资源 https——用安全套接字层传送的超文本传输协议 ftp——文件传输协议 mailto——电子邮件地址 ldap——轻型目录访问协议搜索 file——当地电脑或网上分享的文件 news——Usenet新闻组 gopher——Gopher协议 telnet——Telnet协议 第二部分 文件所在的服务器的名称或IP地址，后面是到达这个文件的路径和文件本身的名称。服务器的名称或IP地址后面有时还跟一个冒号和一个端口号。它也可以包含接触服务器必须的用户名称和密码。路径部分包含等级结构的路径定义，一般来说不同部分之间以斜线（/）分隔。询问部分一般用来传送对服务器上的数据库进行动态询问时所需要的参数。 超文本传送协议HTTPHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 HTTP协议是OSI模型中的第七层应用程中协议具有以下特点： 1、支持客户/服务器模式; 2、简单快速; 3、灵活; 4、无连接; 5、无状态； 给一个简单的实例来看看http协议的执行过程上图中用户点击了一个链接指向清华大学院系设置的页面，其URL是http://www.tsinghua.edu.cn/chn/yxsz/index.htm用http/1.0更具体的说明用户在点击鼠标后发生的事件： （1）浏览器分析链接指向页面的URL。 （2）浏览器向DNS请求解析http://www.tsinghua.edu.cn的IP地址。 （3）域名系统DNS解析出清华大学的IP地址为166.111.4.100。 （4）浏览器与服务器建立TCP连接（服务器的IP地址是166.111.4.100，端口号是80）。 （5）浏览器发出取文件命令：GET/chn/yxsz/index.htm。 （6）服务器http://www.tsinghua.edu.cn做出响应，把文件index.htm发送给浏览器。 （7）释放TCP连接。 （8）浏览器显示“清华大学院系设置”文件index.htm中的所有文件。 浏览器在下载文件时，可以设置为只下载其中的文本部分。这样可使下载的速度加快。在这种情况下，文本中原来嵌入图像或声音的地方只用一个小图标来显示。用户若要下载这些图像或声音，可再用鼠标分别点击这些图标。每点击一次鼠标就重复执行一次类似于上面的8个步骤。也就是先建立TCP连接，再使用TCP连接传送命令和文件，最后释放TCP连接。 HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。 HTTP是无连接的无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端(即浏览器)与服务器之间交换数据的间歇性较大(即传输具有突发性、瞬时性)，并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。 HTTP是无状态的无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。HTTP 是一个无状态协议，这意味着每个请求都是独立的。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。 一次HTTP过程 如上图用户点击某个万维网文档连接时，HTTP协议首先要和服务器建立TCP连接。这是需要三次握手。当三次握手的前两部分完成后（经过了一个RTT时间后），万维网客户就把HTTP请求报文作为第三次握手的第三个报文的数据发送给万维网服务器。万维网服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。 HTTP/1.0协议的缺点HTTP的主要缺点，就是每请求一个文档就要两倍RTT的开销。若一个主页上有很多链接的对象（如图片等）需要一次进行链接，那么每一次链接下载都导致2RTT的开销。另一种开销就是万维网客户和服务器没一次建立新的TCP连接都要分配缓存和变量。 HTTP/1.1协议较好的解决了上面的问题，它使用持续连接。在万维网服务器发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。并且不限于传送同一个页面上链接的文档，而是只要这些文档都在一个服务器上就行。 HTTP/1.1协议的持续连接有两种方式，即非流水线方式和流水线方式。 HTTP的报文结构HTTP有两类报文： （1）请求报文—–从客户端向服务器发送请求报文。（2）响应报文—–从服务器到客户的回答。 请求报文的结构如下图： 响应报文的结构如下图： HTTP请求报文和响应报文都是由三个部分组成。可以看出这两种报文的区别就在于开始行不同。（1）开始行，用于区别是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行就叫做状态行。（2）首部行，用于说明浏览器、服务器、或报文主体的一些信息。首部可以有好几行，但也可以不用。（3）实体主体，在请求报文中一般不用这个字段，在响应报文中返回请求的内容，也可以不用。 请求报文的第一行“请求行”只有三个内容，方法，请求资源的URL，以及HTTP的版本。这里的方法是对请求的对象进行的操作，这些方法实际上也就是一些命令，请求报文的类型就是由它采用的方法决定的。 HTTP的请求方法 1、OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性 2、HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。 3、GET向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。 4、POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 5、PUT向指定资源位置上传其最新内容 6、DELETE请求服务器删除Request-URL所标识的资源 7、TRACE回显服务器收到的请求，主要用于测试或诊断 8、CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 GET和POST的比较GET - 从指定的服务器中获取数据 POST - 提交数据给指定的服务器处理 GET方法： 使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：/test/demo_form.jsp?name1=value1&amp;name2=value2 特点： （1）GET请求能够被缓存 （2）GET请求会保存在浏览器的浏览记录中 （3）以GET请求的URL能够保存为浏览器书签 （4）GET请求有长度限制 （5）GET请求主要用以获取数据 POST方法： 使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：POST /test/demo_form.jspHTTP/1.1 Host: w3schools.comname1=value1&amp;name2=value2 特点： （1）POST请求不能被缓存下来（2）POST请求不会保存在浏览器浏览记录中（3）以POST请求的URL无法保存为浏览器书签（4）POST请求没有长度限制 HTTP状态码HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。状态行包含三项内容，HTTP的版本、状态码、以及解释状态码的简单短语。状态码共分为5大类33种。如： 下面是在状态行中常见的状态码： 100 Continue 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 Accepted 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 400 Bad Request 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 HTTP与HTTPS的区别到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而 HTTP 并非只有好的一面，事物皆具两面性，HTTP 也是有不足之处的。 1、通信使用明文（ 不加密） ， 内容可能会被窃听 2、不验证通信方的身份， 因此有可能遭遇伪装 3、无法证明报文的完整性， 所以有可能已遭篡改 通信使用明文可能会被窃听由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。 HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。 1、无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。 2、无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。 3、无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息， 只想发给特定用户通信的权限。 4、无法判定请求是来自何方、出自谁手。 5、即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS 攻击（ Denial of Service， 拒绝服务攻击） 。 确保 Web 安全的 HTTPS 在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。HTTP+ 加密 + 认证 + 完整性保护 =HTTPS HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS （HTTP Secure）。 参考文献1、计算机网络第五版（谢希仁）2、TCP/IP协议详解卷13、http://www.cnblogs.com/zxj015/p/6530766.html]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>超文本传输协议资源</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--DNS完全解析]]></title>
    <url>%2F2017%2F07%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-DNS%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言前几天，因为要申请一个VR方面的专利在网上找参考资料，准备基于Oculus的sdk进行二次开发。突然发现进不了Oculus的官方网站，后面发现是电脑网络设置中的DNS在作妖。最近几天正好看计算机网络的方面的书，就抽时间把DNS总结一下。 DNS的作用TCP／IP网络中要求每一个互连的计算机都具有其唯一的IP地址，并基于这个IP地址进行通信。由于IP地址是有一串数字组成不好记，因此为每一台计算机赋唯一的主机名，用户可以用要通讯计算机或服务器的主机名而无需直接用IP地址进行通信。但在网络层必须使用IP地址进行，因此域名系统DNS（Domain Name System）是因特网使用的命名系统，用于把便于人们使用的主机名字（如baidu.com）转换为ｉｐ地址。计算机中ｃ盘下会存一个叫做hosts的数据库文件，如下图： 域名解析器 进行域名查询的主机和软件叫做域名解析器。用户使用的工作站或电脑都属于解析器，当某个应用进程要把主机名解析为IP地址使，比如访问（baidu.com）时，就会调用域名解析程序，域名解析程序先访问本地的hosts数据库，大部分的域名解析都在本地进行，如果hosts里面有主机名与对应的IP地址则返回该IP地址。只有hosts里面没有的才会把待解析的域名放在DNS请求报文中以UDP用户报的形式发给本地域名解析器，本地域名解析器在查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的的主机IP地址后就可以进行通信。若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS中的另一个客户，并向其他域名服务器发出查询请求。这个过程直到找到能够回答该请求的域名服务器为止。 域名的构成域名是指为了识别主机名称和组织机构名称而采用的一种具有分层的名称。例如，华中科技大学的域名如下：hust.edu.cn 最左边的 hust 表示华中科技大学，edu表示教育机构，cn表示中国。dns的分层如下图所示： 域名服务器域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层叫做ZONE。如下图所示每一层都有一个域名服务器： 由上图可以得出以下三点结论 ① 各个域的分层上都有各自的域名服务器 ②各层域名服务器都了解该层一下分层中所有域名服务器的IP地址。因此它们从根节点开始呈树状结构相互连接。 ③由于所有域名服务器都了解根域名服务器的IP地址，所以若从根开始按顺序追踪，可以访问世界上所有域名服务器的地址。 根域名服务器：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析（转换为IP地址），只要自己无法解析，就首先要求助于根域名服务器。 DNS查询 域名的查询过程注意两点：①主机向本地域名服务器的查询采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步查询。因此，递归查询返回的结果或者是要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 ②本地域名服务器向根域名服务器的查询通常采用迭代查询。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文是，要么给出所要查询的IP地址，要么告诉域名服务器下一步要向哪个域名服务器进行查询。然后本地域名服务器继续进行下一步查询。 总结其实弄懂DNS主要弄懂两点：①域名解析器 ②域名服务器 参考文献1.计算机网络（第五版）–谢希仁2.图解TCP/IP（第五版）–冈本3.TCP/IP详解4.https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划 Dynamic Programming--从菜鸟到老鸟]]></title>
    <url>%2F2017%2F07%2F15%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming-%E4%BB%8E%E8%8F%9C%E9%B8%9F%E5%88%B0%E8%80%81%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[前言最近在牛客网上做了几套公司的真题，发现有关动态规划（Dynamic Programming）算法的题目很多。相对于我来说，算法里面遇到的问题里面感觉最难的也就是动态规划（Dynamic Programming）算法了，于是花了好长时间，查找了相关的文献和资料准备彻底的理解动态规划（Dynamic Programming）算法。一是帮助自己总结知识点，二是也能够帮助他人更好的理解这个算法。后面的参考文献只是我看到的文献的一部分。 动态规划算法的核心理解一个算法就要理解一个算法的核心，动态规划算法的核心是下面的一张图片和一个小故事。 1234567891011A * &quot;1+1+1+1+1+1+1+1 =？&quot; *A : &quot;上面等式的值是多少&quot;B : *计算* &quot;8!&quot;A *在上面等式的左边写上 &quot;1+&quot; *A : &quot;此时等式的值为多少&quot;B : *quickly* &quot;9!&quot;A : &quot;你怎么这么快就知道答案了&quot;A : &quot;只要在8的基础上加1就行了&quot;A : &quot;所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 &apos;记住求过的解来节省时间&apos;&quot; 由上面的图片和小故事可以知道动态规划算法的核心就是记住已经解决过的子问题的解。 动态规划算法的两种形式上面已经知道动态规划算法的核心是记住已经求过的解，记住求解的方式有两种：①自顶向下的备忘录法 ②自底向上。为了说明动态规划的这两种方法，举一个最简单的例子：求斐波拉契数列Fibonacci 。先看一下这个问题： 12345Fibonacci (n) = 1; n = 0Fibonacci (n) = 1; n = 1Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2) 以前学c语言的时候写过这个算法使用递归十分的简单。先使用递归版本来实现这个算法：12345678910public int fib(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; return fib( n-1)+fib(n-2);&#125;//输入6//输出：8 先来分析一下递归算法的执行流程，假如输入6，那么执行的递归树如下： 上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行，fib(2)被重复执行了5次。由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把执行过的子节点保存起来，后面要用到的时候直接查表调用的话可以节约大量的时间。下面就看看动态规划的两种方法怎样来解决斐波拉契数列Fibonacci 数列问题。 ①自顶向下的备忘录法12345678910111213141516171819202122public static int Fibonacci(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; for(int i=0;i&lt;=n;i++) Memo[i]=-1; return fib(n, Memo); &#125; public static int fib(int n,int []Memo) &#123; if(Memo[n]!=-1) return Memo[n]; //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。 if(n&lt;=2) Memo[n]=1; else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo); return Memo[n]; &#125; 备忘录法也是比较好理解的，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。比如上面的递归树中在计算fib（6）的时候先计算fib（5），调用fib（5）算出了fib（4）后，fib（6）再调用fib（4）就不会在递归fib（4）的子树了，因为fib（4）的值已经保存在Memo[4]中。 ②自底向上的动态规划备忘录法还是利用了递归，上面算法不管怎样，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）……,那么何不先计算出fib（1），fib（2），fib（3）……,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。 12345678910111213public static int fib(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; Memo[0]=0; Memo[1]=1; for(int i=2;i&lt;=n;i++) &#123; Memo[i]=Memo[i-1]+Memo[i-2]; &#125; return Memo[n];&#125; 自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。观察参与循环的只有 i，i-1 , i-2三项，因此该方法的空间可以进一步的压缩如下。 12345678910111213141516public static int fib(int n) &#123; if(n&lt;=1) return n; int Memo_i_2=0; int Memo_i_1=1; int Memo_i=1; for(int i=2;i&lt;=n;i++) &#123; Memo_i=Memo_i_2+Memo_i_1; Memo_i_2=Memo_i_1; Memo_i_1=Memo_i; &#125; return Memo_i; &#125; 一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。你以为看懂了上面的例子就懂得了动态规划吗？那就too young too simple了。动态规划远远不止如此简单，下面先给出一个例子看看能否独立完成。然后再对动态规划的其他特性进行分析。 动态规划小试牛刀例题：钢条切割 上面的例题来自于算法导论关于题目的讲解就直接截图算法导论书上了这里就不展开讲。现在使用一下前面讲到三种方法来来实现一下。①递归版本1234567891011public static int cut(int []p,int n) &#123; if(n==0) return 0; int q=Integer.MIN_VALUE; for(int i=1;i&lt;=n;i++) &#123; q=Math.max(q, p[i-1]+cut(p, n-i)); &#125; return q; &#125; 递归很好理解，如果不懂可以看上面的讲解，递归的思路其实和回溯法是一样的，遍历所有解空间但这里和上面斐波拉契数列的不同之处在于，在每一层上都进行了一次最优解的选择，q=Math.max(q, p[i-1]+cut(p, n-i));这个段语句就是最优解选择，这里上一层的最优解与下一层的最优解相关。 ②备忘录版本 12345678910111213141516171819202122public static int cutMemo(int []p) &#123; int []r=new int[p.length+1]; for(int i=0;i&lt;=p.length;i++) r[i]=-1; return cut(p, p.length, r); &#125; public static int cut(int []p,int n,int []r) &#123; int q=-1; if(r[n]&gt;=0) return r[n]; if(n==0) q=0; else &#123; for(int i=1;i&lt;=n;i++) q=Math.max(q, cut(p, n-i,r)+p[i-1]); &#125; r[n]=q; return q; &#125; 有了上面求斐波拉契数列的基础，理解备忘录方法也就不难了。备忘录方法无非是在递归的时候记录下已经调用过的子函数的值。这道钢条切割问题的经典之处在于自底向上的动态规划问题的处理，理解了这个也就理解了动态规划的精髓。 ③自底向上的动态规划 12345678910111213public static int buttom_up_cut(int []p) &#123; int []r=new int[p.length+1]; for(int i=1;i&lt;=p.length;i++) &#123; int q=-1; //① for(int j=1;j&lt;=i;j++) q=Math.max(q, p[j-1]+r[i-j]); r[i]=q; &#125; return r[p.length]; &#125; 自底向上的动态规划问题中最重要的是理解注释①处的循环，这里外面的循环是求r[1],r[2]……，里面的循环是求出r[1],r[2]……的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。下面是长度为4的钢条划分的结构图。我就偷懒截了个图。 动态规划原理虽然已经用动态规划方法解决了上面两个问题，但是大家可能还跟我一样并不知道什么时候要用到动态规划。总结一下上面的斐波拉契数列和钢条切割问题，发现两个问题都涉及到了重叠子问题，和最优子结构。 ①最优子结构 用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。 ②重叠子问题 在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。 动态规划的经典模型线性模型线性模型的是动态规划中最常用的模型，上文讲到的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。【例题1】是一个经典的面试题，我们将它作为线性模型的敲门砖。 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 每次过桥的时候最多两个人，如果桥这边还有人，那么还得回来一个人（送手电筒），也就是说N个人过桥的次数为2*N-3（倒推，当桥这边只剩两个人时只需要一次，三个人的情况为来回一次后加上两个人的情况…）。有一个人需要来回跑，将手电筒送回来（也许不是同一个人，realy？！）这个回来的时间是没办法省去的，并且回来的次数也是确定的，为N-2，如果是我，我会选择让跑的最快的人来干这件事情，但是我错了…如果总是跑得最快的人跑回来的话，那么他在每次别人过桥的时候一定得跟过去，于是就变成就是很简单的问题了，花费的总时间： T = minPTime * (N-2) + (totalSum-minPTime) 来看一组数据 四个人过桥花费的时间分别为 1 2 5 10，按照上面的公式答案是19，但是实际答案应该是17。 具体步骤是这样的： 第一步：1和2过去，花费时间2，然后1回来（花费时间1）； 第二歩：3和4过去，花费时间10，然后2回来（花费时间2）； 第三部：1和2过去，花费时间2，总耗时17。 所以之前的贪心想法是不对的。我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i] (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2a[2] (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2a[2] } 区间模型区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时，在X两边各添加一个字符’a’后，aXa仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有 d[i][j] = d[i+1][j-1] （这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策： 1、在A[j]后面添加一个字符A[i]； 2、在A[i]前面添加一个字符A[j]； 根据两种决策列出状态转移方程为： d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1) 空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。 背包模型背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来。 【例题3】有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为： f[i][v] = max{ f[i-1][v], f[i-1][v – Ci] +Wi } 时间复杂度O(VN)，空间复杂度O(VN) （空间复杂度可利用滚动数组进行优化达到O(V) ）。 动态规划题集整理1、最长单调子序列Constructing Roads In JG Kingdom★★☆☆☆Stock Exchange ★★☆☆☆ 2、最大M子段和Max Sum ★☆☆☆☆最长公共子串 ★★☆☆☆ 3、线性模型 Skiing ★☆☆☆☆ 总结弄懂动态规划问题的基本原理和动态规划问题的几个常见的模型，对于解决大部分的问题已经足够了。希望能对大家有所帮助，转载请标明出处http://write.blog.csdn.net/mdeditor#!postId=75193592，创作实在不容易，这篇博客花了我将近一个星期的时间。 参考文献1.算法导论]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--深入理解ArrayList实现原理]]></title>
    <url>%2F2017%2F05%2F19%2FJava%E8%BF%9B%E9%98%B6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ArrayList简介ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了Collection和List接口，可以灵活的设置数组的大小。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 ArrayList的继承关系123public class ArrayList&lt;E&gt;extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable 由上可知ArrayList继承AbstractList 并且实现了List和RandomAccess，Cloneable, Serializable接口。 ArrayList的方法使用和源码解析①构造方法 1234567891011121314151617181920212223//1-----------------------public ArrayList() &#123; this(10); //调用ArrayList(10) 默认初始化一个大小为10的object数组。 &#125; //2-------------------------public ArrayList(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); //如果用户初始化大小小于0抛异常，否则新建一个用户初始值大小的object数组。 this.elementData = new Object[initialCapacity]; &#125; //3--------------------------public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // 当c.toArray返回的不是object类型的数组时，进行下面转化。 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; 由上面三种构造方法可知，默认情况下使用ArrayList会生成一个大小为10的Object类型的数组。也可以调用ArrayList(int initialCapacity) 来初始化Object数组的大小。并且用户可以往ArrayList中传入一个容器只要这个容器是Collection类型的。调用ArrayList(Collection&lt;? extends E&gt; c)接口的时候会将容器数组化处理并将这个数组值赋给Object数组。 实例： 1234567891011121314151617181920public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list_2=new ArrayList&lt;Integer&gt;(20); //list_2中添加元素 for(int i=0;i&lt;10;i++) list_2.add(i); ArrayList&lt;Integer&gt; list_3=new ArrayList&lt;Integer&gt;(list_2); //输出list_2中元素 for(Integer a:list_2) System.out.print(a+&quot; &quot;); //输出list_3中元素 for(Integer a:list_3) System.out.print(a+&quot; &quot;); &#125;//输出/*list_2 : 0 1 2 3 4 5 6 7 8 9 -----------------------list_3 : 0 1 2 3 4 5 6 7 8 9 */ ②indexOf(Object o)方法功能：查找某个元素在ArrayList中第一次出现的位置。123456789101112131415public int indexOf(Object o) &#123;//ArrayList中的元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; //如果没有找到对应的元素返回-1。 return -1; &#125; 对于indexof方法做几点说明：ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 。 12345678910111213141516171819202122232425public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(null); list.add(2); list.add(3); System.out.println(&quot;null: &quot;+list.indexOf(null)); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;2: &quot;+list.indexOf(2)); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;4: &quot;+list.indexOf(4)); &#125; //输出 /* null: 2 ------------------------- 2: 1 ------------------------- 4: -1 */ ③lastIndexOf(Object o)方法功能：查找某个元素在ArrayList中最后出现的位置。1234567891011121314public int lastIndexOf(Object o) &#123; if (o == null) &#123; //如果o为null从后往前找到第一个为null的下标 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; //从后往前找到第一个值为o的下标 for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 上面代码做几点说明：lastIndexOf(Object o)在ArrayList中从后往前找到第一个跟要查找值相同的元素的下标，因为是按值查找所以对于 null 要单独查找。如果未找到则返回-1； ④get(int index)方法功能：返回ArrayList中指定下标为index的元素。 123456789101112131415public E get(int index) &#123; //检查index的值是否大于ArrayList的大小 rangeCheck(index); //返回index下标的元素 return elementData(index); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125; //这里值检查index &gt;= size的情况，因为index&lt;0时会自动抛出异常，所以并未检查index&lt;0的情况。 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 对上面代码做几点说明：上面代码中只检查了index&gt;=size的情况，在index=size要检查的原因是有可能数组的大小大于index，然而有效里面的元素&lt;index这时不抛异常就会返回无效值。举个例子ArrayList的初始化大小为10，现在往里面放5个元素，如果index&gt;=5时，应该要抛出异常，而不是返回 null。因为null 是可以主动放在ArrayList中的。 ⑤set(int index, E element)方法功能：将element放到ArrayList下标为index的位置，如果index=size 抛异常，set(int index, E element)只能覆盖ArrayList中原来的元素，返回值为被覆盖的元素。 123456789101112131415//1public E set(int index, E element) &#123;//检查index是否小于size，如果不是抛异常 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //覆盖ArrayList中index上的元素。 return oldValue; //返回被覆盖的元素。 &#125;//2 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; ⑥add(E e)方法功能：往ArrayList中添加元素。 12345678910111213141516171819202122232425262728//1-----------------------public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 加入元素前检查数组的容量是否足够 elementData[size++] = e; return true; &#125;//2----------------------- private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // 如果添加元素后大于当前数组的长度，则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //3----------------------- private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //将数组的长度增加原来数组的一半。 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果扩充一半后仍然不够，则 newCapacity = minCapacity;minCapacity实际元素的个数。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //数组最大位2^32 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; add方法比较复杂，涉及到扩充数组容量的问题。其中要弄清楚size和elementData.length的区别，size指的是数组中存放元素的个数，elementData.length表示数组的长度，当new一个ArrayList系统默认产生一个长度为10的elementData数组，elementData.length=10，但是由于elementData中还未放任何元素所有size=0。如果加入元素后数组大小不够会先进行扩容，每次扩容都将数组大小增大一半比如数组大小为10一次扩容后的大小为10+5=10;ArrayList的最大长度为 2^32 . ⑦add(int index, E element)方法功能：往ArrayList指定index上添加元素，添加元素后ArrayList的大小增1。index及以后的元素都会向后移一位。 1234567891011121314151617181920212223//1-------------------------public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index的值是否在0到size之间，可以为size。 ensureCapacityInternal(size + 1); // 看elementData的长度是否足够，不够扩容 //将elementData从index开始后面的元素往后移一位。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;//2-------------------------private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //3------------------------- private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; add(int index, E element)往指定index中加入元素，加入元素之前先检查数组的大小，如果小了在原来基础上增大一半，将ArrayList只能怪index及以后的元素往后移一位，将element放到index位置。 ⑧remove(int index)方法功能：删除ArrayList指定位置的元素。123456789101112131415public E remove(int index) &#123; rangeCheck(index);//如果index&gt;=size抛出异常 modCount++; E oldValue = elementData(index);//获取删除元素的值 int numMoved = size - index - 1; //将index后面所有的元素往前移一位。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work//返回要删除的原数。 return oldValue; &#125; ⑨remove(Object o)方法功能：删除ArrayList中值为o的元素 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;]]></content>
      <tags>
        <tag>ArrayList</tag>
        <tag>实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--从源码理解Integer类的toString方法]]></title>
    <url>%2F2017%2F05%2F15%2FJava%E8%BF%9B%E9%98%B6-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3Integer%E7%B1%BB%E7%9A%84toString%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java中的jdk是深入学习Java编程的宝库，其中各种方法的实现不仅可以深入了解 设计模式的应用，还可以看到jdk编写者如何优化代码（这种优化已经到达了一种极端的程度）对我们编写自己的代码是有十分重要的作用的。read the fucking source code 是成为一名优秀程序猿必须的经历。本博客通过分析Integer类的toString方法来看看jdk编写者如何编写他们的代码的。 Integer类的toString的基本用法12345678910111213141516171819202122232425262728293031323334353637383940public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer OUT_MAX_VALUE=new Integer(Integer.MAX_VALUE+1); Integer MAX_VALUE=new Integer(Integer.MAX_VALUE); Integer MIN_VALUE=new Integer(Integer.MIN_VALUE); Integer NOR_VALUE=new Integer(-128); Integer OUT_MIN_VALUE=new Integer(Integer.MIN_VALUE-1); System.out.println(&quot;max_val :&quot;+MAX_VALUE.toString()); System.out.println(&quot;max_val :&quot;+MAX_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;out_max :&quot;+OUT_MAX_VALUE.toString()); System.out.println(&quot;out_min :&quot;+OUT_MIN_VALUE.toString()); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;min_val :&quot;+MIN_VALUE.toString()); System.out.println(&quot;min_val :&quot;+MIN_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;nor_val :&quot;+NOR_VALUE.toString()); System.out.println(&quot;nor_val :&quot;+NOR_VALUE); &#125;&#125;//输出/*max_val :2147483647max_val :2147483647-------------------------out_max :-2147483648out_min :2147483647-------------------------min_val :-2147483648min_val :-2147483648-------------------------nor_val :-128nor_val :-128*/ 由上面可知直接输出Integer的值和调用Integer类的toString方法是一样的，其实直接打印一个对象的时候就是调用了该对象的toString方法。调用toString方法的时候其实输出的是Integer的value值，toString方法就是把int类型的value值转化为string类型输出。注意一下几点： ①Integer的value值从 Integer.MIN_VALUE 到 Integer.MAX_VALUE 如果超出了这个范围就会得到一些奇怪的结果。 ②在Integer.MAX_VALUE基础上加1输出的结果是个负值。 ③在Integer.MIN_VALUE基础上加1输出的结果是个正值。 Integer类的toString的源码分析下面就深入看看Integer类的toString方法是如何实现的。还是直接上源码。 123456789101112131415161718192021 public String toString() &#123; return toString(value); &#125;//------------------------------ public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return &quot;-2147483648&quot;; //如果是最小值直接返回其字符串因为Integer.MIN_VALUE=-2147483648 ，这样可以节省下面计算时间 //① int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); //获取整数值的长度10进制 char[] buf = new char[size]; //② getChars(i, size, buf); //得到整数中的每一个字符 //③ return new String(buf, true); //返回字符串值 &#125; 上面的代码做几点说明：①如果Integer的value值正好是 Integer.MIN_VALUE 直接返回 “-2147483648” 节省时间。②得到integer值的十进制的长度，如果负数先求出绝对值的长度，然后再长度加1，因为负数的符号位占一位。③得到integer的value值的每一个字符。④得到的字符新建字符串返回。下面看看 stringSize方法是怎样实现的： 123456789 static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1; //看看x到底是几位数 &#125;//----------------------------------final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;; 上面的 stringSize 非常的巧妙的来整数的长度，首先定义了一个数组这个数组中分别存放了一位十进制的最大值，二位十进制的最大值，依次到 Integer.MAX_VALUE为止，因为integer的最大值为 Integer.MAX_VALUE，也就是说integer的最大长度为10位。注意：①stringSize(int x) 中的参数x 必须是正整数。下面用一个实例看看stringSize(int x)方法。 1234567891011121314151617181920212223242526272829303132public class IntegerDemo &#123; public static void main(String[] args) &#123; int x=199; int max=Integer.MAX_VALUE; int out_max=Integer.MAX_VALUE+1; System.out.println(stringSize(x)); System.out.println(&quot;-------------------------&quot;); System.out.println(stringSize(max)); System.out.println(&quot;-------------------------&quot;); System.out.println(stringSize(out_max)); &#125; final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;; static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1; &#125;&#125;//输出/*3-------------------------10-------------------------1*/ 上面的199小于999所以位数为3，而 out_max的值因为超过了 Integer.MAX_VALUE是个负数，得到的长度为1，因此求负数的长度时必须将其转化为正数来求，而且求出的长度还要加上一位来放‘ - ’。得到integer的value值的长度后使用 getChars 方法来得到value的每一位上的字符。下面看看这个getChars方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static void getChars(int i, int index, char[] buf) &#123; int q, r; int charPos = index; char sign = 0; if (i &lt; 0) &#123; sign = &apos;-&apos;; i = -i; &#125; // 当i &gt;= 65536的时候每一次获取两位的char值。 while (i &gt;= 65536) &#123; q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); //使用移位操作快速计算出q*100，2^6+2^5+2^2=64+32+4=100. i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; &#125; // 当 i &lt;= 65536的时候每次只获取一位的char值 // assert(i &lt;= 65536, i); for (;;) &#123; q = (i * 52429) &gt;&gt;&gt; (16+3); //q/10,2^19=524288, (double)52429/(1&lt;&lt;19)=0.10000038146972656 r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; &#125; if (sign != 0) &#123; buf [--charPos] = sign; //如果是负数加上符号位 &#125; &#125;//--------------------------------------final static char [] DigitOnes = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &#125; ;//--------------------------------------final static char [] DigitTens = &#123; &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &#125; ; getChars方法也是十分的巧妙①在 i &gt;= 65536 的时候每次能够求出2位的char 值，求2位的char值时利用了两个数组 DigitOnes 和 DigitTens 就是在这两个数组的帮助下才能一次求出2位的char值下面就简单的说一下怎样利用这两个数组来分别求出个位和十位上的值的，假如现在得到两位数是 65，个位上是 5 要得到个位上的5，这时候不管十位是多少个位上一定是5，所以数组DigitOnes的 05，15，25，35，45，55，65，75，85，95位置上都是 5，这样不管是25，还是35 都能得到个位上的5。在来看看如何得到十位上的数，还是65，十位是6，所以DigitTens 的60，61，62，63，64，……69 位置上都是6。 ② q = (i * 52429) &gt;&gt;&gt; (16+3);这段代码其实就是q=i/10 ,其中 (double)52429/(1&lt;&lt;19)=0.10000038146972656也就是在int型的时候计算一个数的十分之1的精度是够的，可以看出jdk开发者的这种优化意识是非常强的。③(q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2) 这段等价于q100，因为 q2^6+q2^5+q2^2=q(64+32+4)=100q.这里为什么不直接使用q100，而要使用位移操作，因为其实q*100底层还是要进行位移操作的，直接使用位移操作效率更高，这也给我们编程带来启示。能够优化的时候一定要优化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--ArrayDeque双端队列完全解析]]></title>
    <url>%2F2017%2F05%2F09%2FJava%E8%BF%9B%E9%98%B6-ArrayDeque%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayDeque的基本用法1234567891011121314151617181920212223public class DequeDemo &#123; public static void main(String[] args) &#123; int []arr=&#123;1,2,3,4,5,6,7,8&#125;; ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(); for(int i=0;i&lt;arr.length;i++) &#123; if((i&amp;1)==0) //如果i是偶数从队头加入，否则从队尾加入 aDeque.addFirst(arr[i]); else aDeque.addLast(arr[i]); &#125; while(!aDeque.isEmpty()) &#123; aDeque.pollFirst(); aDeque.pollLast();//此处不严谨但是由于arr的元素恰好是偶数个，本例中也不会出现问题。 &#125; &#125;&#125; 上面这段程序简单的演示了如果对双端队列的操作，下面给出上面代码的示意图： 上图是在执行完往双端队列加元素后，双端队列中元素的存储情况，由上图可以得出以下几点结论：①ArrayDeque 默认分配16个空间的数组。数组下标从0-15。②addFirst(arr[i]) 操作是将元素从数组的最后一个位置向前依次存放。③addLast(arr[i]) 操作是将元素从数组的第一个位置依次向后存放。 上面的图是分别在执行一次pollFirst() 和 pollLast() 后双端队列中的存储情况。由上图可知一下几点：①如果单独将addFirst(arr[i]) 和pollFirst() 结合使用的话，先进的元素会后出队，后进的元素反而先队，实现的是栈的功能。②如果单独将addLast(arr[i]) 和pollLast() 结合使用的话，先进的元素会后出队，后进的元素反而先队，实现的也是栈的功能。 再看下面的代码： 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; int []arr=&#123;1,2,3,4,5,6,7,8&#125;; ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(); //从双端队列的头部加元素 for(int i=0;i&lt;arr.length;i++) aDeque.addFirst(arr[i]); //从双端队列的尾部删元素 while(!aDeque.isEmpty()) aDeque.pollLast(); &#125;&#125; 上面代码中依次从队头加入元素，然后在队尾删除元素下面是示意图： 使用addFirst(arr[i]) 将元素全部加到双端队列中。 进行一次pollLast() 后队列中元素的情况。进行3次pollLast() 后队列中元素的情况。 由上可以得出以下几点：①如果单独将addFirst(arr[i]) 和pollLast() 结合使用的话，先进的元素会先出队，后进的元素会后出队，实现的是普通队列。②如果单独将addLast(arr[i]) 和pollFirst() 结合使用的话，先进的元素会先出队，后进的元素会后出队，实现的也是普通队列。 深入了解ArrayDeque下面从源码来看看ArrayDeque是如何实现上述功能的。 构造函数默认构造函数新建了一个大小为16的数组。1234public ArrayDeque() &#123; elements = (E[]) new Object[16]; //默认构造函数新建了一个大小为16的数组。 &#125; 用户初始化大小的构造函数。123public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125; 上面的构造函数中只用到 allocateElements(numElements) 下面看看allocateElements(numElements) 的源码 1234567891011121314151617private void allocateElements(int numElements) &#123; int initialCapacity = 8; if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) initialCapacity &gt;&gt;&gt;= 1;// 最大分配2 ^ 30 空间 &#125; elements = (E[]) new Object[initialCapacity];&#125; 上面的这段代码做一下几点说明：①当用户要求分配的数组大小小于8时，分配8个空间，当用户要求分配的数组大小为8时分配16个空间。②当用户要求分配的数组大小大于8时则分配大于用户需要内存的2的最小幂，比如用户需要分配的数组大小为21时，系统会分配大小为32的数组。③最大分配2 ^ 30 大小的数组。 传入容器的构造函数123456public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); //分配数组 addAll(c); // 将元素加入到 ArrayDeque中&#125; 下面看看 addAll(c) 的代码： 12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; //将元素全部加到ArrayDeque中。其中add 方法调用了addLast 后面会对addLast源码进行分析 &#125; public boolean add(E e) &#123; addLast(e); return true; &#125; 下面利用 ArrayDeque(Collection&lt;? extends E&gt; c) 这个构造器来实现一个简单的例子： 12345678910111213public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); //初始化的时候传入一个List的容器。 ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); while(!aDeque.isEmpty()) System.out.print(aDeque.pollLast()+&quot; &quot;); &#125; &#125; 上面代码中初始化时传入一个List的容器，下面示意图看看构造后的ArrayDeque是什么样的。 由上图可知：将list的元素加入到ArrayDeque中的时候是调用了addLast 方法，addList 方法是按顺序从前往后加入的。 addFirst12345678910public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); //如果加入的元素为null 抛出空指针异常。 elements[head = (head - 1) &amp; (elements.length - 1)] = e; //head值先减1，然后将元素放到head位置 if (head == tail) doubleCapacity(); //如果head == tail 将数组大小扩大一倍 &#125; 上面的tail 和 head到底是啥，还是画图来看看。由上图可知①addFirst 加一个元素时，head都会先减1，然后再放元素。head初始值为 0。② (head - 1) &amp; (elements.length - 1) 使head的值在【0， elements.length - 1】范围之内，同时可以循环利用数组里面的空间，head一直围着数组转圈。③如果tail==head 的时候，由上图可知数组中的元素已经满了，所以会将数组的扩大一倍。初始时tail=0。 addLast12345678public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; //将e的值放到tail位置，然后tail+1，如果数组满了扩容一倍。 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; 由上面的图可知 addLast 时操作 tail 在tail位置加入元素，如果数组已经满了就扩容一倍。 pollFirst123456789public E pollFirst() &#123; int h = head; E result = elements[h]; //将elements[h]赋值给result。 if (result == null) return null;//如果result 为null 直接返回 elements[h] = null; // 如果result不为null 将elements[h] 赋值为null head = (h + 1) &amp; (elements.length - 1);// head+1. return result; &#125; 下面是一个使用pollFirst() 的例子。 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); for(int i=0;i&lt;3;i++) aDeque.addFirst(arr[i]); //往双端队列中添加元素 while(!aDeque.isEmpty()) aDeque.pollFirst(); //使用pollFirst()删除。 &#125; &#125; 下面看看上面代码的流程图：添加完元素后的双端队列。执行一次pollFirst() 后。执行两次pollFirst()之后执行三次pollFirst()之后执行6次pollFirst()之后。通过上面的图就很好理解pollFirst() 的删除流程了。 pollLast12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); E result = elements[t]; //tail 先减1然后获取tail中的内容。 if (result == null) return null;//如果result 为null 直接返回 elements[t] = null;//否则将t位置的元素清空再返回result tail = t; return result; &#125; 还是利用上面的那段代码只不过将pollFirst（） 改为pollLast() 代码如下 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); for(int i=0;i&lt;3;i++) aDeque.addFirst(arr[i]); //添加元素 while(!aDeque.isEmpty()) aDeque.pollLast(); //删除元素 &#125; &#125; 依然上图：添加完元素的队列。执行一次pollLast() 后。执行8次pollLast() 后。执行9次pollLast() 后。由上面可以总结出：①每次pollLast()前tail先减1，然后再删除，tail指向的位置在元素的上一个位置。② pollLast() 也是绕着数组循环删除的。tail一直绕着数组循环转动。 removeFirst()12345678public E removeFirst() &#123; E x = pollFirst(); //调用pollFirst() if (x == null) throw new NoSuchElementException(); //当pollFirst()返回null抛出null 元素异常。 return x; &#125; 由上面代码可知其实removeFirst() 就是调用pollFirst() 不同之处在于在当pollFirst()返回null removeFirst() 抛出 null 元素异常。 removeLast()1234567public E removeLast() &#123; E x = pollLast(); //调用 pollLast() 当pollLast()返回null抛出null 元素异常。 if (x == null) throw new NoSuchElementException(); return x; &#125; 由上面代码可知其实removeLast() 就是调用pollLast() 不同之处在于在当pollLast()返回null removeLast() 抛出 null 元素异常。 add(E e)12345public boolean add(E e) &#123;//调用 addLast(e); 添加成功返回 true。 addLast(e); return true; &#125; remove()123public E remove() &#123; return removeFirst(); &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ArrayDeque</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java堆结构PriorityQueue完全解析]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%A0%86%E7%BB%93%E6%9E%84PriorityQueue%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在堆排序这篇文章中千辛万苦的实现了堆的结构和排序，其实在Java 1.5版本后就提供了一个具备了小根堆性质的数据结构也就是优先队列PriorityQueue。下面详细了解一下PriorityQueue到底是如何实现小顶堆的，然后利用PriorityQueue实现大顶堆。 PriorityQueue的数据结构 PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。 PriorityQueue的操作①add(E e) 和 offer(E e) 方法 add(E e) 和 offer(E e) 方法都是向PriorityQueue中加入一个元素，其中add（）其实调用了offer（）方法如下： 123public boolean add(E e) &#123; return offer(e); &#125; 下面主要看看offer（）方法的作用：如上图调用 offer（4）方法后，往堆中压入4然后从下往上调整堆为小顶堆。offer（）的代码实现： 1234567891011121314151617public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); //如果压入的元素为null 抛出异常 int i = size; if (i &gt;= queue.length) grow(i + 1); //如果数组的大小不够扩充 size = i + 1; if (i == 0) queue[0] = e; //如果只有一个元素之间放在堆顶 else siftUp(i, e); //否则调用siftUp函数从下往上调整堆。 return true; &#125; 对上面代码做几点说明：①优先队列中不能存放空元素。②压入元素后如果数组的大小不够会进行扩充，上面的queue其实就是一个默认初始值为11的数组（也可以赋初始值）。③offer元素的主要调整逻辑在 siftUp ( i, e )函数中。下面看看 siftUp(i, e) 函数到底是怎样实现的。 123456789101112private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; 上面的代码还是比较简明的，就是当前元素与父节点不断比较如果比父节点小就交换然后继续向上比较，否则停止比较的过程。 ② poll() 和 remove() 方法 poll 方法每次从 PriorityQueue 的头部删除一个节点，也就是从小顶堆的堆顶删除一个节点，而remove（）不仅可以删除头节点而且还可以用 remove(Object o) 来删除堆中的与给定对象相同的最先出现的对象。先看看poll（）方法。下面是poll（）之后堆的操作 删除元素后要对堆进行调整： 堆中每次删除只能删除头节点。也就是数组中的第一个节点。将最后一个节点替代头节点然后进行调整。如果左右节点中的最小节点比当前节点小就与左右节点的最小节点交换。直到当前节点无子节点，或者当前节点比左右节点小时停止交换。 poll（）方法的源码 123456789101112131415public E poll() &#123; if (size == 0) return null; //如果堆大小为0则返回null int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null;//如果堆中只有一个元素直接删除 if (s != 0) siftDown(0, x);//否则删除元素后对堆进行调整 return result; &#125; 看看 siftDown(0, x) 方法的源码： 1234567891011121314151617private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = key; &#125; siftDown（）方法就是从堆的第一个元素往下比较，如果比左右孩子节点的最小值小则与最小值交换，交换后继续向下比较，否则停止比较。remove（4）的过程图：先用堆的最后一个元素 5 代替4然后从5开始向下调整堆。这个过程和poll（）函数一样，只不过poll（）函数每次都是从堆顶开始。remove(Object o)的代码：123456789101112public boolean remove(Object o) &#123; int i = indexOf(o); //先在堆中找到o的位置 if (i == -1) return false; //如果不存在则返回false。 else &#123; removeAt(i); //否则删除数组中第i个位置的值，调整堆。 return true; &#125; &#125; removeAt(int i)的代码123456789101112131415161718private E removeAt(int i) &#123; assert i &gt;= 0 &amp;&amp; i &lt; size; modCount++; int s = --size; if (s == i) // removed last element queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved); if (queue[i] == moved) &#123; siftUp(i, moved); if (queue[i] != moved) return moved; &#125; &#125; return null; &#125; 使用PriorityQueue实现大顶堆PriorityQueue默认是一个小顶堆，然而可以通过传入自定义的Comparator函数来实现大顶堆。如下代码： 1234567 private static final int DEFAULT_INITIAL_CAPACITY = 11;PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;Integer&gt;(DEFAULT_INITIAL_CAPACITY, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125; &#125;); 实现了一个初始大小为11的大顶堆。这里只是简单的传入一个自定义的Comparator函数，就可以实现大顶堆了。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀树（Trie）原理及Java实现]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89%E5%8E%9F%E7%90%86%E5%8F%8AJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前缀树的结构Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树或键树，是一种多叉树结构。如下图：上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：①根节点不包含字符，除根节点外的每一个子节点都包含一个字符。②从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。③每个节点的所有子节点包含的字符互不相同。④从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点。 前缀树的应用1、前缀匹配2、字符串检索3、词频统计4、字符串排序 下面看看怎样使用前缀树来实现前缀匹配的。 前缀匹配了解了前缀树的结构后，就可以利用前缀树的性质来解决现实中的问题。比如说查找一个字符串数组中是否含有前缀单词，什么是前缀单词：上面的 in，就是 inn 的前缀单词。如果有十几万条单词，并且每个单词的长度都是5-10以内，这样必定存在大量重复的字符，因此利用前缀树来求解不仅速度快而且空间复杂度也比较好。①定义前缀树结构1234class Tries&#123; Boolean isTrie ; HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); &#125; 上面的 isTrie 用来标记单词是否遍历完。children表示该节点的子节点。如上面的t节点的子节点有o和e两个。 ②建立前缀树12345678910111213141516171819202122232425262728293031323334353637public static boolean insertNode(String str,Tries head)&#123; if(str==null||str.length()==0) return false; //如果插入的单词为null 或者单词长度为0直接返回false，false代表该单词不是前缀树中某个单词的前缀， //或者前缀树中某个单词是该单词的前缀。 char chs[]=str.toCharArray(); int i=0; Tries cur=head; //将字符串的每个字符插入到前缀树中 while(i&lt;chs.length) &#123; if(!cur.children.containsKey(chs[i])) &#123; cur.children.put(chs[i], new Tries()); //如果当前节点中的子树节点中不包含当前字符，新建一个子节点。 &#125; //否则复用该节点 cur=cur.children.get(chs[i]); if(cur.count==true) &#123; System.out.println(&quot; trie tree&quot;); return true; //判断前缀树中是否有字符串为当前字符串的前缀。 &#125; i++; &#125; cur.count=true; if(cur.children.size()&gt;0) &#123; System.out.println(&quot; trie tree&quot;); return true; //判断当前字符串是否是前缀树中某个字符的前缀。 &#125; return false;&#125; 前缀树的建立过程就是插入字符串的过程，同时在插入节点的时候可以判断插入的字符串是否是前缀树里面某个单词的前缀，或者前缀树中的某个单词是否是该单词的前缀。 ①先将字符串转换为字符数组，然后对每个字符进行处理，如果当前节点的子节点中包含有要处理的字符字节复用。否则新建一个子节点。②判断是否是前缀单词的时候，有两个步骤，首先要看该字符串是否是其他字符串的前缀，还有看其他字符串是否是当前字符串的前缀。 判断前缀单词的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class isTrie &#123; public static void main(String[] args) &#123; Tries tries=new Tries(); String strs[]=&#123;&quot;abc&quot;,&quot;abd&quot;,&quot;b&quot;,&quot;abdc&quot;&#125;; for(int i=0;i&lt;strs.length;i++) insertNode(strs[i], tries); &#125;public static boolean insertNode(String str,Tries head) &#123; if(str==null||str.length()==0) return false; char chs[]=str.toCharArray(); int i=0; Tries cur=head; while(i&lt;chs.length) &#123; if(!cur.children.containsKey(chs[i])) &#123; cur.children.put(chs[i], new Tries()); &#125; cur=cur.children.get(chs[i]); if(cur.count==true) &#123; System.out.println(&quot; trie tree&quot;); return true; &#125; i++; &#125; cur.count=true; if(cur.children.size()&gt;0) &#123; System.out.println(&quot; trie tree&quot;); return true; &#125; return false; &#125;&#125;class Tries&#123; boolean isTrie; HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法--最大存水量问题]]></title>
    <url>%2F2017%2F04%2F29%2F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%98%E6%B0%B4%E9%87%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：给出一个数组代表围柱的高度，求能围柱的最大的水量，例如数组{ 5，2，3，2，4 }，最大水量为5。 如下图：黄色部分为围柱，绿色部分是能够围住的水，图中围柱的高度依次为 5，2，3，2，4最多能围住的水量是5。 思路：求出每个柱子上面能够存多少水，然后将每根柱子的存水量相加便能得到总的存水量，为求出每根柱子上能够存多少水，就要求出每根柱子左边最高的和右边最高柱子，然后用两者的最小值减去当前柱子的高度。 例如图中从左到右第二根柱子的高度为2，它左边最高柱子的值为5，右边最高柱子的值为4，因此它的最大存水量为 Min（4，5）-2=2。 解法1利用上面思路，从左到右遍历每根柱子，遍历的时候求出每根柱子左边最高和右边最高柱子的值，然后利用s两者的最小值减去当前柱子的高度就行了。时间复杂度O（n^2）,空间复杂度O（1）。 123456789101112131415161718192021222324public static int water1(int []arr) &#123; int water=0; //water 用于保存最大存水量 if(arr==null||arr.length&lt;=1) return 0; //如果只有一根柱子围不住水。 int leftLargest=0,rightLargest=0; //leftLargest,rightLargest 分别用于保存遍过程中，当前元素左边最大值，和右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=0; rightLargest=0; for(int j=0;j&lt;i;j++) leftLargest=Math.max(leftLargest,arr[j]); //先求出当前元素左边最大值。 for(int j=arr.length-1;j&gt;i;j--) rightLargest=Math.max(rightLargest, arr[j]); //最求出当前元素右边最大值 water+=Math.min(leftLargest, rightLargest)&gt;arr[i]?Math.min(leftLargest, rightLargest)-arr[i]:0;//左边最大值和右边最大值的最小值与当前元素比较如果小于当前元素，则当前元素上水量为0，围不住水，如果大于当前元素，则减去当前元素得到存水量。 &#125; return water; &#125; 注意：① 如果当前柱子大于它左右最大值的任何一个是存不了水的。 解法2分析上面的算法发现算法的时间复杂度为O（n^2）的原因是对于每个元素都要从左到右，和从右到最左遍历其两边最大值，假如使用两个数组 left[ ] , right[ ]来保存每个元素左边最大值，右边最大值的话，这样就不用每次都遍历了，因此时间复杂度可以减少到O（n），但空间复杂度为O（n），典型的空间换时间算法。如下图：对于数组{ 5, 2 , 6 , 2 , 4 }它的左右数组如下左数组：右数组 1234567891011121314151617181920212223242526272829public static int water1(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int leftLargest=0,rightLargest=0; int left[]=new int[arr.length]; //left 数组中保存每个元素左边的最大值，left[i]，表示数组中第i个元素的左边最大值。 int right[]=new int[arr.length]; //right数组中保存每个元素左边的最大值，right[i]，表示数组中第i个元素的右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=Math.max(leftLargest,arr[i]); left[i]=leftLargest; &#125; //先遍历一次找出每个元素左边最大值。 for(int i=arr.length-1;i&gt;=0;i--) &#123; rightLargest=Math.max(rightLargest,arr[i]); right[i]=rightLargest; &#125; //遍历找到每个元素右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; water+=Math.min(left[i],right[i])&gt;arr[i]?Math.min(left[i],right[i])-arr[i]:0; &#125; //利用当前元素的左边最大值和右边最大值求得存水量。 return water; &#125; 上面算法的流程：①从左到右遍历一次求出每个元素左边的最大值，保存在 left 数组中。②从右到左遍历一次求出每个元素右边的最大值，保存在right数组中。③最后一次遍历求出每个元素（每根柱子）的存水量。 改进解法2 ：分析上面算法发现其实没有必要使用 left 数组，因为当从左到右遍历求存水量的过程中可以利用一个变量来保存当前元素左边的最大值。代码如下 12345678910111213141516171819202122public static int water1(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int leftLargest=0,rightLargest=0; int right[]=new int[arr.length]; //只用一个右数组来保存从右到左的最大值。 for(int i=arr.length-1;i&gt;=0;i--) &#123; rightLargest=Math.max(rightLargest,arr[i]); right[i]=rightLargest; &#125; for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=Math.max(leftLargest, arr[i]); //leftLargest 保存当前元素左边的最大值。 water+=Math.min(leftLargest,right[i])&gt;arr[i]?Math.min(leftLargest,right[i])-arr[i]:0; &#125; return water; &#125; 解法3能不能在时间复杂度O（n），空间复杂度O（1）的情况下来完成存水量的问题，答案是肯定的，用几幅图来描述一下解法3的过程。数组为 { 5，2，3，2，4 }。 ①上面左右两边的黄色块分别表示当前元素左边最大值和右边最大值。 ②left ，right分别代表从左到右移动和从右到左移动的指针。 ③如果当前元素的左边最大值比右边最大值小，则left指针向右移动，否则right指针向左移动。 ④这种左右指针移动的目的是为了保证所求的左右最大值一定是当前元素的左右最大值。 1234567891011121314151617181920212223242526public static int water3(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int largestLeft=0,largestRight=0; //分别保存左右两边最大值 int left=0,right=arr.length-1; while(left&lt;right) &#123; largestLeft=Math.max(arr[left], largestLeft); largestRight=Math.max(arr[right], largestRight); //获得左右两边最大值 if(largestLeft&gt;largestRight) &#123; //如果左边最大值大于右边则右指针向移动 water+=largestRight-arr[right--]; &#125; else &#123; //否则左指针向右移动 water+=largestLeft-arr[left++]; &#125; &#125; return water; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最大存水量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试算法经典--最长括号匹配]]></title>
    <url>%2F2017%2F04%2F27%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8-%E6%9C%80%E9%95%BF%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在求最长括号匹配之前先看看括号下面这个问题： 括号匹配“ {（）}”这种是括号匹配，而 “{ ] ] { ” 这种就不是括号匹配。判断一个给定的括号字符串是否是匹配的。对于括号匹配这类的问题可以使用 Stack来处理：1 . 当碰到”( [ { “这些左括号就进栈。2 . 如果碰到“) ] }”这些右括号时，如果栈为空，则肯定不匹配，返回false。如果栈不为空，则出栈比较两个括号是否匹配不匹配返回 false 。3 . 如果遍历完整个括号串后栈为空返回true，否则返回false。 例：” ( { } ) [ ] “的匹配过程如下： ①颜色相同的表示同一类型的左右括号。 ②碰到两个左括号将它们入栈。 ③碰到右括号时出栈比较，如果相同出栈，不同直接返回false。 ④匹配完后栈为 null 返回 true，否则返回 false。12345678910111213141516171819202122232425262728293031323334353637public boolean isMatch(String str) &#123; if(str==null||str.length()==0) return false; //如果给出的字符串是null 或者长度为0返回false。 char chs[]=str.toCharArray(); Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); int i=0; String left=&quot;([&#123;&quot;; //用left保存左括号的类型，便于比较。 String right=&quot;)]&#125;&quot;; //用right 保存右括号的类型，便于比较。 while(i&lt;chs.length) &#123; if(left.contains(chs[i]+&quot;&quot;)) &#123; //如果是左括号，加入栈中 stack.push(chs[i]); &#125; else &#123; //如果是右括号，如果栈为null 返回false，否则比较栈顶元素与当前元素是否匹配。 if(stack.isEmpty()) &#123; return false; &#125; else &#123; char topchar=stack.pop(); if(left.indexOf(topchar)!=right.indexOf(chs[i])) //如果左右括号不匹配返回false。 return false; &#125; &#125; i++; &#125; return stack.isEmpty(); //如果栈为空，则返回 true，否则返回 false。 &#125; 最长括号匹配求一个括号串的最长括号子串的长度，如 “ ) ( ( ) ( ) ”的最长子串为“ ( ) ( ) ”长度为4。 方法1（暴力法 时间复杂度O（n^2）,空间复杂度O（n）） 用二重循环遍历每一个子串，子串是括号匹配的获得子串的长度，使用一个max_len 保存最大括号匹配子串的长度。优点：当左右括号的类型不唯一时也可以判断，缺点：时间复杂度大。 代码 1234567891011121314151617181920212223public static int longestMatch(String str) &#123; if(str==null||str.length()==0) return 0; int max_len=0; for(int i=0;i&lt;str.length()-1;i++) &#123; for(int j=i+1;j&lt;str.length();j++) &#123; String subString=str.substring(i, j+1); //遍历每一个子串，如果子串是括号匹配的，更新最大值。 //BracketsMatch.isMatch(subString)就是上面括号匹配方法。 if(BracketsMatch.isMatch(subString)) &#123; max_len=Math.max(max_len, j-i+1); &#125; &#125; &#125; return max_len; &#125; 方法2（ 时间复杂度O（n）,空间复杂度O（n）） 利用栈来保存括号的下标信息，并用变量 last 来保存不是匹配括号的最后一个下标，开始时 last=-1，如）（）（）），开始时 last=-1 ，当碰到左括号时，入栈，碰到右括号时如果栈为空则 last=当前有括号的下标，否则出栈，如果出栈后栈为空，则长度为 当前下标- last 。否则为当前下标- 栈的下一个元素。 1234567891011121314151617181920212223242526272829303132public static int longestMatch(String str) &#123; if(str==null||str.length()==0) return 0; char chs[]=str.toCharArray(); Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); //注意这种方法只能判断一种类型的左右括号，不能同时判断两种及以上的左右括号。 int i=0,last=-1,max_len=0; while(i&lt;chs.length) &#123; if(chs[i]==&apos;(&apos;) &#123; stack.push(i); &#125; else &#123; if(stack.isEmpty()) &#123; last=i; &#125; else &#123; stack.pop(); if(stack.isEmpty()) max_len=Math.max(max_len, i-last); else &#123; max_len=Math.max(max_len, i-stack.peek()); &#125; &#125; &#125; i++; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--深入解析hashmap]]></title>
    <url>%2F2017%2F04%2F22%2FJava%E8%BF%9B%E9%98%B6-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90hashmap%2F</url>
    <content type="text"><![CDATA[HashMap原理先以一个简单的例子来理解hashmap的原理。在Java中先随机产生一个大小为20的数组如下： hash表的大小为7，将上面数组的元素，按mod 7分类如下图： 将这些点插入到hashmap中（简单hashmap）后如下图： 由上图可知：① hashmap是用链地址法进行处理，多个key 对应于表中的一个索引位置的时候进行链地址处理，hashmap其实就是一个数组+链表的形式。 ② 当有多个key的值相同时，hashmap中只保存具有相同key的一个节点，也就是说相同key的节点会进行覆盖。 ③在hashmap中查找一个值，需要两次定位，先找到元素在数组的位置的链表上，然后在链表上查找，在HashMap中的第一次定位是由hash值确定的，第二次定位由key和hash值确定。 ④节点在找到所在的链后，插入链中是采用的是头插法，也就是新节点都插在链表的头部。 ⑤在hashmap中上图左边绿色的数组中也存放元素，新节点都是放在左边的table中的，这个在上图中为了形象的表现链表形式而没有使用。 HashMap上面只是简单的模拟了hashmap 真实的hashmap的基本思想和上面是一样的不过更加复杂。HashMap中的一个节点是一个Entity 类如下图： Entry是HashMap的内部类 包含四个值（next，key，value，hash），其中next是一个指向 Entry的指针，key相当于上面节点的值 value对应要保存的值，hash值由key产生，hashmap中要找到某个元素，需要根据hash值来求得对应数组中的位置，然后在由key来在链表中找Entry的位置。HashMap中的一切操作都是以Entry为基础进行的。HashMap的重点在于如何处理Entry。因此HashMap中的操作大部分都是调用Entry中的方法。可以说HashMap类本身只是提供了一个数组，和对Entry类中方法的一些封装。 下面从源码方面对 HashMap进行解析： ①HashMap的继承关系123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 从上面可以看到HashMap继承了AbstractMap , 并且实现了Cloneable, Serializable 接口。 ②HashMap的构造函数下面的代码都是经过简化处理的代码，基本流程不变只是为了更好的理解修改和删除了一部分内容 1234567891011121314151617181920public HashMap(int initialCapacity, float loadFactor) &#123;/*initialCapacity 初始化hashmap中table表的大小，前面的图中左边绿色部分的数组就是table。loadFactor填装因子。*/ if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //如果初始化大小小于0，抛出异常 if (initialCapacity &gt; 2^30) initialCapacity = 2^30; //HashMap 中table的最大值为2^30。 /* 生成一个比initialCapacity小的最大的2的n次方的值，这个值就是table的大小。table就是一个Entry类型的数组。 */ int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; table = new Entry[capacity];//新建一个Entry类型的数组，就是前面图中左边的数组。不过数组的元素是Entry类型的。 &#125; 上面的代码要做几点说明： ①填装因子:loadFactor 表示填装因子的大小，简单的介绍一下填装因子：假设数组大小为20，每个放到数组中的元素mod 17，所有元素取模后放的位置是（0–16） 此时填装因子的大小为 17/20 ,装填因子就为0.85啦，你装填因子越小，说明你备用的内存空间越多，装填因子的选定，可以影响冲突的产生，装填因子越小，冲突越小。 ②HashMap初始化过程就是新建一个大小为capacity，类型为Entry的数组，Entry上面已经介绍过这个类，包含一个指针一个key，一个value，和一个hash。capacity是2的次幂，至于为什么是2的次幂后面会有介绍的。 下面是另外两个构造函数123456789 public HashMap(int initialCapacity) &#123; HashMap(initialCapacity, 0.75); //调用了上面的构造函数，只不过使用了默认的填装因子0.75 &#125;public HashMap() &#123; HashMap(16, 0.75); //生成一个table大小为16，填装因子0.75的HashMap &#125; ③由上可知如果用户直接使用HashMap（）构造函数来new一个HashMap 会生成一个大小为16，填装因子为0.75的 HashMap。 ③HashMap中的put（key，value）函数还是先上源码 12345678910111213141516171819202122232425public V put(K key, V value) &#123; if (key == null) return putForNullKey(value);/*如果key为null则调用 putForNullKey(value) 函数 这个函数先在table[0]这条链上找有没有key 为null的元素如果有就覆盖，如果没有就新建一个new一个key为null，value=value hash=0，的Entry放在table[0]。*/ int hash = hash(key);//获得key的hash值 int i = indexFor(hash, table.length);//由hash值确定放在table表中的那一条链上。类似于取模后放在数组中的哪个位置。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; //如果链上原来有一个hash值相同，且key相同的则用新的value值进行覆盖。 &#125; &#125;//否则利用hash，key，value，new一个Entry对象插入到链表中。 modCount++; addEntry(hash, key, value, i); return null; &#125; 对上面代码做几点说明： ① HashMap中的key可以为 null ，此时hash=0，为什么key可以为null，因为HashMap中放的元素是Entry，而Entry包含了4个值（key，value，hash，next），key为 null 时不影响Entry映射到HashMap中。 ②hash(key)，产生一个正整数，这个整数与key相关。这个hash（key）函数比较关键，后面会进行说明。 ③用户插入的（key，value）对不是直接放到HashMap中的，而是用（key，value）以及后面由key value产生的hash，new一个Entry对象后再插入到HashMap中的。 ④如果对应的链上有一个hash值个key相同的Entry则覆盖value值，不new Entry对象，如果没有会先new 一个对象在将其插到对应的链上。（其中可能会涉及到扩充HashMap）。 下面看看hash（key）函数 123456789final int hash(Object k) &#123; int h = 0; h ^= k.hashCode(); //hashCode 返回一个整数值，这个值跟对象有关，不同对象的hashCode值一般不同。 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; hash函数的作用是使hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 ④HashMap中的get(Object key)函数上源码 123456789101112131415161718192021222324252627282930public V get(Object key) &#123; if (key == null) return getForNullKey();//如果key==null则在table[0]这条链上找，如果找到返回value值，否则返回null ，因为key==null的都是放在table[0]这条链上的。 Entry&lt;K,V&gt; entry = getEntry(key);// getEntry(key)先key的hash值找到在数组的哪条链上，然后在链上查找key相同的如果没找到返回null //如果找到了返回Entry的value值。 return null == entry ? null : entry.getValue(); &#125;private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 上面代码的几点说明 ① 通过key来链表中查找元素包括两个过程，先由hash找到链（hash由key产生，不同的key可能产生相同的hash值，相同的hash值放在同一条链上），再用key在链上找。 ② 如果key为null则只在table[0]和其链上查找，因为key为null都放在table[0]及其链上了。 ③因为在HashMap中查找到的是Entry对象，返回的值是Entry对象的value值。 重点Entry类其实理解HashMap最重要的在于理解Entry类，Entry类相当于链表中的一个节点，是HashMap操作的基础。下面主要从Entry类的几个方法来理解Entry类和HashMap的关系。 ①Entry中的addEntry( hash, key, value, bucketIndex)函数在HashMap中调用put（key，value）时，如果（key，value）是首次加入到HashMap中，就会调用addEntry( hash, key, value, bucketIndex)函数，将其加入到table表对应的位置中（注意是table中，不是后面的链中，首次加入的元素都是采用的头插法）。下面是源码： 12345678910111213141516171819202122void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); //如果size的值超过了threshold，将table扩容两倍 hash = (null != key) ? hash(key) : 0; //如果key为null则hash=0，否则hash函数利用key来产生hash值。 bucketIndex = indexFor(hash, table.length); //bucketIndex就相当于取模后对应的table表中的哪个位置。 &#125; //如果不存在容量不够问题则直接新建一个Entry对象。 createEntry(hash, key, value, bucketIndex); &#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //获得原来首位的Entry对象 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //将新建的Entry对象放在链表的首位，然后用next指向原来放在首位的对象。也就是头插。 size++; &#125; 上面代码的几点说明：①bucketIndex是由hash取模后对应于table表中的哪个位置。indexFor(hash, table.length)其实是一个取模函数。它的实现很简单 hash&amp; (length-1)，就是用hash值与上table表的长度减1。 ②并不是对每一个（key，value）对都产生一个Entry对象，只是（key，value）对首次放到HashMap中时，或者HashMap中没有相同的key时，才产生一个Entry对象，否则如果有相同的key则会直接将value值赋个Entry的value。 ③新产生的Entry都是放在了table中，也就是链表的首位，采用链表的头插法。 ②HashMap中的keySet()函数作用：返回HashMap中key的集合。keySet是HashMap中的内部类： 12345678910111213141516171819202122232425262728public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); //如果keyset为null就产生一个keyset对象。 &#125; private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); //newKeyIterator迭代器用于遍历key。 &#125; public int size() &#123; return size; //返回keyset的大小 &#125; public boolean contains(Object o) &#123; return containsKey(o); //是否包含某个key &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; //移除某个key的Entry。 &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; keySet是用来遍历整个HashMap的，因此是十分重要的，下面做几点说明。①keyset中有一个迭代器可以迭代的获取下一个key的值，通过key的值就可以获得Entry对象了。 ②对应key的迭代遍历是table表中由左向右，由上向下进行的，也就是先遍历table[0]这条链上的，然后遍历table[1]这条链上的依次往下进行。 ③newKeyIterator具体实现这里就不多介绍，只要知道上面的功能怎么实现就可以了。 下面是利用keyset来实现遍历HashMap的例子： 1234567891011121314HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;Integer, Integer&gt;(); for(int i=0;i&lt;20;i++)&#123; hashMap.put(i, i+1);&#125;//新建一个hashmap往里面放入20个（key，value）对。Iterator&lt;Integer&gt; iterator= (Iterator&lt;Integer&gt;) hashMap.keySet().iterator();//获得keyset的iterator，进行遍历整个hashmap。while(iterator.hasNext())&#123; Integer key=(Integer) iterator.next(); Integer val=(Integer)hashMap.get(key); System.out.println(key+&quot;: &quot;+val);&#125; ②HashMap中的entrySet()函数作用：返回HashMap中Entry的集合。对于entrySet这里就不上源码了，举一个使用entrySet遍历HashMap的例子： 123456789101112HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;Integer, Integer&gt;(); for(int i=0;i&lt;20;i++) &#123; hashMap.put(i, i+1); &#125; Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator=hashMap.entrySet().iterator(); while(iterator.hasNext()) &#123; Entry entry= iterator.next(); System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue()); &#125; 使用entrySet()函数遍历比keySet()函数遍历快，因为keySet()函数是先通过entrySet()求出key然后在通过key来遍历获得Entry的，所以速度比entrySet()慢很多。参考文献：①http://blog.csdn.net/jiary5201314/article/details/51439982②http://www.cnblogs.com/chenssy/p/3521565.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
</search>
