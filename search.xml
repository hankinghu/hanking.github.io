<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android及时通讯和sns开源项目汇总]]></title>
    <url>%2F2018%2F02%2F01%2FAndroid%E5%8F%8A%E6%97%B6%E9%80%9A%E8%AE%AF%E5%92%8Csns%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[这是一个整理即时通讯（IM）和社交系统（SNS）优秀开源项目的文档，项目上传github欢迎提交更新。 一 即时通讯和社交系统平台 1 环信(推荐)2 阿里百川 云旺3 融云4 OpenSNS…… #二 基于环信的即时通讯开源项目数据整理自环信官网，网络数据和github。更多信息请参考环信官方网站和ImGeek1 高仿微信：基于环信SDK高仿微信 介绍:图忆是一款基于位置信息的分享与社交应用。实现了将用户记录的不同类型的事件标刻于地图之上，查看自己的记录足迹，同时用户可以轻松查看附近分享的记事，添加好友聊天，建立兴趣圈子，发现志趣相投的好友，并且用户记事可以分享到公共社区平台，分享乐趣的同时也发现了更多的乐趣，社区推荐策略让用户发现更多有价值的乐趣。功能模块: 消息：订阅号、列表滑动删除、TitleBar弹出菜单单聊，群聊（发送文字，语音，位置，视频，文件，语音电话，视频通话）微信表情、通讯录：按字母索引排序、添加手机通讯录好友、发现：二维码扫描添加好友、二维码扫描加入群聊、扫码微信支付、生成自己二维码图片朋友圈、发布朋友圈信息、购物、游戏、设置WebView与Javascript交互、播放视频、加载HTML5页面FastJson Json转换神器、Imageloader图片加载库、android-async-http 网络请求库、图片缩放查看、加密解密效果展示: 源码链接:https://github.com/CameloeAnthony/wechat 2 宅不住 介绍：宅不住，发现城市精彩运动，认识周边潮人。类似与周末去哪儿 app, 同时加入了社交模块，即时聊天功能。功能模块: 主页、附近的活动、附近的潮人; 发布活动、搜索活动;专题、及时通讯（环信SDK）;登陆（个人主页）、设置模块;效果展示：源码链接：http://pan.baidu.com/s/1sl7oSnN 3 图忆：基于位置信息的分享与社交应用 介绍:图忆是一款基于位置信息的分享与社交应用。实现了将用户记录的不同类型的事件标刻于地图之上，查看自己的记录足迹，同时用户可以轻松查看附近分享的记事，添加好友聊天，建立兴趣圈子，发现志趣相投的好友，并且用户记事可以分享到公共社区平台，分享乐趣的同时也发现了更多的乐趣，社区推荐策略让用户发现更多有价值的乐趣。功能模块: 【记录记忆】你可以记录自己的生活点滴在地图之上，可以公开给别人看，也可以保存为自己的私有记忆。【离线记录】没有网络也可以轻松保存离线记录，WIFI连接后直接批量上传，省心【地图附近】你将通过地图查看到附近用户公开的说有分享记录，当然是直接在地图上展示的哟，很直观的说，还有五个标签分类查询哟，就等你来发现了。【雷达】发现同时在附近开启雷达的小伙伴，自定义雷达显示的内容，让小伙伴更容易发现你【聊天圈子】与TA尽情畅聊，兴趣小伙伴建圈子一起聊。【图忆社区】点赞，评论，分享，收藏Ta的分享效果展示:源码链接: https://github.com/donlan/Tuyi 4 咚咚：一款高效团队沟通的移动客户端 介绍:基于环信平台进行开发，旨在打造的高效团队沟通的移动客户端，供企业内部协作使用、适应移动办公需要，提升企业沟通协同效率，增强企业办公管理效率。（当前仅实现了用户登入登出功能、通讯功能、投票功能。）具体功能说明功能模块: 一、用户登录注册功能1.系统登录界面2系统注册界面 注册功能实现：限制账号长度必须为11位，出生日期选择，头像选择（从系统自带头像中选择）3.系统首页 登陆成功，即进入系统主页面4.个人信息查看及修改 进入主页面后点击个人信息查看，即可查看相关信息，并对其进行修改 主界面（1）头像修改功能实现（2）名字修改功能实现（3）部门修改功能实现（4）性别选择功能实现（5）个性签名修改功能实现二、通讯功能主界面功能实现：群组聊天，单对单私人聊天，查看好友列表，查看好友详情，查看群组详情三、投票功能主界面功能实现：展示用户发起的投票列表，新增投票，投票提交。效果展示:源码链接:https://github.com/caisiyi/SYTeamApp 5 美肤GO：专注于个人海外代购及护肤咨询分享的APP 介绍:希望给爱美向往美的你一个全方位的秘密基地，也希望给想要做全职代购或者兼职代购甚至只是旅游顺便想代购挣回机票钱的我一个平台，源于这个初衷，美肤GO提供高品质的代购机制和最亲民线下般体验的护肤资讯，只为让你更美丽！功能模块: 个人海外代购美妆美肤课程社区分享互动等效果展示: 源码链接:https://github.com/Rabbit00/MeifuGO 6 方圆十里：关注方圆十里内的人和事 介绍:基于IM(环信通信云)+LBS(百度地图SDK+GeoHash距离算法)的社交APP功能模块: 一、功能列表：1、登录、注册（采用后端授权注册的方式绑定环信id，更安全）2、用户资料：头像、昵称、性别、生日、地区（本地arrays.xml存储地区数据库）、个性签名3、Tab1.-“人”—- 百度地图中显示十公里内的人（如果用户位置集中或者人数过少会导致无法测试，因此“更远”选项，搜寻更多，并且本身的十公里概念也未进行筛选）4、Tab2.“事”—-十公里内的动态–文字、图片、位置的动态（发布、回帖、通知提醒）5、Tab3.“聊”—-IM会话6、Tab4. “友”—通讯录及好友申请7、我的动态8、二维码—通过扫二维码加好友二、特点备注：1、本项目中采用geohash算法编码用户的位置坐标，达到位置的粗分区，而后进行精确精算实现十公里之内的人和事的概念。2、创建自定义的百度地图标注。3、一套将环信IM系统和开发者自身的用户体系融合的解决方案（当前的解决方案在多个项目中得到检验，成熟稳定）。4、常见的发帖回复模块的处理解决。5、利用环信的透传消息进行用户的帖子发布、回复等提醒通知。（待更新）6、UI优化，如电话聊天背景的取自用户头像的毛玻璃特效–参考微信电话聊天背景（待更新）效果展示: 源码链接:https://github.com/huangfangyi/fangyuanshili 7 在哪：基于环信sdk的陌生人交友android版本 介绍:图忆是一款基于位置信息的分享与社交应用。实现了将用户记录的不同类型的事件标刻于地图之上，查看自己的记录足迹，同时用户可以轻松查看附近分享的记事，添加好友聊天，建立兴趣圈子，发现志趣相投的好友，并且用户记事可以分享到公共社区平台，分享乐趣的同时也发现了更多的乐趣，社区推荐策略让用户发现更多有价值的乐趣。功能模块: 基于环信sdk的陌生人交友android版本开源了—在哪（微话聊） 该项目是改编自环信即时通讯云的demo改编，新增了一些功能 环信即时通讯云demo包含了一个接近微信的完整的聊天app的所有功能, 包括发文字，表情，图片，语音，位置，群聊，登录，注册，退出登录等。效果展示: 源码链接:https://github.com/vasth/zaina 8 店话：基于react native 和 环信的实时通话 介绍:用“店话”搜索想要找的店铺电话，也可以上传自己的店铺信息和在线的客户免费语音通话，语音通话的流量仅仅需要3-5kb/s啊，还不快快下载！功能模块: 免费语音通话效果展示:源码链接:https://github.com/vasth/dianhua 9 Baby 介绍:这是一款使用了Material Design和MVP的情侣之间使用的app。试用了一下。效果很不错。功能模块: 属于两个人的朋友圈，两个人聊天，登陆注册效果展示: 源码链接:https://github.com/rogerou/Baby 10 “约个球”：作者本人的开源项目，目前正在开发中。后续将会使用环信SDK作为即时通讯支持，目前使用的是阿里百川的云旺。也会不断完善项目架构的搭建。全程博客更新，github项目维护。 介绍:“约个球”APP是一款基于android系统开发的以球类运动为主题的社交app平台，注册“约个球”，你可以同自己的联系人进行沟通交流。你也可以在这里找到附近喜欢打球的人，填写自己的信息（如：选择自己喜欢的球类运动，打哪个位置，打了几年球之类的）。迅速发现附近各种球类运动场所。更重要的是，在“约个球”你随时都可以知道附近有哪些朋友正在战斗，你可以加入进去，也可以自行组建自己的战队。你也可以发起“约架”，邀请附近联系人队伍来一场精彩的篮球赛、足球赛……为球类运动爱好者提供一个在线交友的平台，为线下的球类运动助力。功能模块: 1 聊天模块2 联系人模块3 附近信息模块4 资讯模块5 个人信息模块效果展示:源码链接:https://github.com/CameloeAnthony/MVPCommon ！！！！如果你有更好的即时通讯项目和社交app，欢迎提交到github。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>即时通讯</tag>
        <tag>sns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo入门]]></title>
    <url>%2F2018%2F02%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git安装上传本地代码及遇到的问题]]></title>
    <url>%2F2018%2F01%2F30%2Fgit%E5%AE%89%E8%A3%85%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[GitGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Windows版本Git下载地址https://git-scm.com/download/win下载下来后直接点击exe文件完成安装。 上传本地代码到Github上 要上传代码到github上先要在github上注册用户，注册完成后记住用户名和密码， 然后在github上新建一个repository，如图： 创建完成后会进入到如下界面： 上图中有三种上传代码到github上的方式，因为我们是新用户选择第一种方式来上传代码或者项目。上传项目主要分为6个步骤 步骤1cd到你的本地项目根目录下，执行git命令 git init 步骤2将项目的所有文件添加到仓库中 git add . 如果想添加某个特定的文件，只需把.换成特定的文件名即可 步骤3将add的文件commit到仓库 git commit -m “注释语句” 上面的 “注释语句”可以代替成任何自己想注释的语句。 步骤4 将本地的仓库关联到github上 git remote add origin https://github.com/hankinghu/709.git注意：其中https://github.com/hankinghu/709.git 是在上图中用红线标出的地址。也就是新建的repository的地址。 步骤5上传github之前，要先pull一下，执行如下命令： git pull origin master 敲回车后，会执行输出类似如下 步骤6最后一步，上传代码到github远程仓库 git push -u origin master 执行完后，如果没有异常，等待执行完就上传成功了，中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了 Git更新本地代码到Github上如果是第一次，可以使用可以使用win+R键切换到cmd命令行形式 ： 步骤一git clone https://github.com/hankinghu/NewEQingJiang.git 先将git上的代码下载到本地。 步骤二先 使用cd 切换到刚才下载到本地的文件根目录下。 git add . 注意 . 和 add 中间有空格 步骤三git commit -m “初始化个人主页仓库” 步骤四git push 提交到github上。 注意：如果上面的git代码已经下载到本地，直接对更改的文件进行步骤二、三、四。 Git上传中遇到的异常异常1：fatal: remote origin already exists.解决方法 在上面步骤3的后面 1、先删除远程 Git 仓库 git remote rm origin 2、再添加远程 Git 仓库 git remote add origin https://github.com/hankinghu/709.git 异常2：fatal: refusing to merge unrelated histories异常2出现的原因一般为repository中已存在一个项目，又上传另一个项目。 解决方法 在进行git pull 时，添加一个可选项git pull origin master –allow-unrelated-histories windows命令行切换目录的方式 1.切换到C盘根目录 打开终端cmd后，输入cd C:\（一定要加上后面的反斜扛） 2.切换到C盘子目录 打开终端cmd后，输入cd C:\dir1（切换到C盘下目录dir1） 3.切换到其他盘根目录 打开终端cmd后，输入D:（不需要加cd，一定不要加反斜扛） 4.切换到其他盘子目录 打开终端cmd后，先切换到根目录，再使用cd命令切换到子目录]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git安装</tag>
        <tag>fatal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书感想]]></title>
    <url>%2F2017%2F11%2F15%2F%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言 自从9月份开始找工作，已经很长时间没有写博客了。最近对文化大革命特别感兴趣，看了一些关于文革的书籍，如季羡林的《牛棚杂忆》，梁晓声的《一个红卫兵的自白》，余华的《兄弟》，杨显惠的命运三部曲《夹边沟记事》、《定西孤儿院纪事》、《甘南纪事》，傅高义的《邓小平时代》，刘少奇的《刘少奇日记》，罗斯·特里尔的《毛泽东传》，以及王大宾的《王大宾回忆录》终于对文化大革命的起因有了更加详细的了解。 文化大革命的原因发生在20世纪60年代中国大陆的文化大革命，实质上是毛泽东发动群众、介入中国共产党党内斗争的一场政治运动。反思这场文革运动，不只要研究毛泽东为何发动文革运动、为何能够发动这场文革运动，还要研究毛泽东怎样审时度势，发动和领导这场文革运动的，他的战略目标、战略部署，大势的掌控，主动进攻，被动应对，策略转换等等。总之，你不把毛泽东的想法、做法搞懂、搞清楚、搞明白，你对文革运动的反思，你对文革运动的回忆，往往就容易失实，失之于偏。这也是认识论的观点，只有理解了的东西才能更深刻地感觉它。 毛泽东发动文革运动的战略目标，是要打碎刘少奇掌控一线所建立与运作的权力系统，毛泽东要重回一线重建他能亲自掌控与运作的新的权力系统，在过程中发现和培养坚持执行毛泽东主张的社会主义路线的接班人，保证其社会主义路线的传承。毛泽东认为，他的这个战略目标，已不能用依合法程序的会议政变形式实现，必须借助群众运动的力量。由此，毛泽东在完成发动文革运动的准备，制定和发出“5•16通知”，启动文革运动后十年，有三个不同的战略运作阶段：1966年5月16日至1967年1月，为破坏旧秩序，打碎刘少奇掌控一线所建立与运作的权力系统阶段；1967年1月至1969年4月九大召开，为建立新秩序，以三结合的革命委员会形式，重建新的权力系统的阶段；1969年4月至1976年9月，为巩固通过文革运动所建立的新秩序阶段。《王大宾回忆录》根据这个认识，回忆和反思了他的文革运动经历。王大宾是北京地质学院的学生。北京地质学院文革运动中成立的群众组织“东方红公社”，以及由它发起和为头成立的“首都大专院校红卫兵革命造反总司令部”（简称“首都三司”），成为文革运动破坏旧秩序阶段反工作组造反派的旗帜、破坏旧秩序的先锋队。1967年3月5日，取代朱成昭成为地院东方红一把手的王大宾，后亦被毛泽东美誉为北京五大学生领袖之一。 1966年，北京59个大专院校，北大、清华、地院，在文革运动发动、动员群众破坏旧秩序阶段，在不同时段分别起了带头与示范作用。而抓典型引路正是毛泽东一贯的工作方法。 “5•16通知”下发后，毛泽东在捕捉发动群众的突破口。5月23日，吴传启等人在中国科学院哲学社会科学部（简称“学部”），贴出了批判原北京市委宣传部长、时任学部副主任兼政治部主任杨述的大字报，但并不具有动员群众的典型作用。5月25日，聂元梓等7人在北京大学贴出了批评宋硕、陆平、彭珮云的大字报。毛泽东得知后，立即批示在中央人民广播电台广播。果如所料，一石激起千重浪，全国沸腾，学校师生对学校党委领导批判造反的热情高涨。因北大四清运动，以聂元梓等人为代表的四清运动的积极分子，与彭真支持的陆平为首的校党委早已处在严重分歧与对立冲突中。打压他们的彭真，在“5.16通知”传达时已被点名批判，给了聂元梓等人勇气和批判方向。对北大四清运动的情况、分歧与冲突，毛泽东应早已知晓。张恩慈关于这方面的意见函毛泽东已有批示。北京大学的地位与影响不言而喻。聂元梓等7人的大字报被誉为第一张马列主义大字报，在文革运动破坏旧秩序阶段，作为发动群众投入文革运动的第一把火，其作用与影响确是历史的事实。 毛泽东欲擒故纵。刘少奇误判文革运动，采取派工作组的方式搞了一场“反右派”运动（有的工作组称为“抓游鱼”等），他还派王光美做清华工作组的顾问——实际上让她掌控清华工作组，介入清华文革运动，意欲再创一个类似四清“桃园经验”的“清华经验”。王光美在清华五十天，指导工作组打压反对工作组的学生和教师，结果搞出七八百名右派，其典型人物就是蒯大富，所以当时清华的右派也被称为“蒯派”。清华这次“反右派”运动成了1966年8月1日召开的八届十一中全会上压倒刘少奇的最顕着的一根稻草。毛泽东决定，刘少奇不再主持中央一线工作，决定撤出领导文革运动的工作组，让群众自己解放自己。1966年8月1日，毛泽东给清华大学附属中学的红卫兵写信，表示对红卫兵“说明对反动派造反有理”大字报的“热烈支持”。中国大陆的人民群众，自此在文革运动前期有了毛泽东领导下的结社自由。毛泽东更在1966年8月18日，穿上绿军装，戴上北京师范大学附属女子中学红卫兵、宋任穷女儿宋彬彬献上的红卫兵袖章，在天安门城楼检阅了来自全国各地的百万革命群众，公开表达了对红卫兵造反的支持。蒯大富对抗王光美主导的工作组个案，清华大学的地位与影响，无疑是毛泽东打破刘少奇一线主导的旧秩序的利器。 八届十一中全会后，周恩来、陶铸在文革运动的前线主持中央日常工作。文革运动出现了延续工作组路线的保工作组保守派群众组织，与反工作组的造反派群众组织的严重分歧与对立。在文革运动的这一时段，被薄一波“6•22批示”打压、视为“右派”的北京地质学院的少数师生，以平民子弟为主体，在1966年8月17日成立的北京地质学院东方红公社，以其鲜明、激进的反工作组路线的造反方向，第一个组织带领上千人的队伍，到地质部机关上访请愿的造反行动，震动京城，亦惊动了毛泽东。毛泽东与江青的女儿肖力，随时了解与掌握了这一时段地院文革运动的情况、态势。9月6日，联合北京高校反工作组造反派群众组织，以地院东方红为头的“首都三司”成立。“首都三司”代表的反工作组造反派组织，成立之初虽然处于少数派地位，但它符合毛泽东的战略部署，代表在文革运动第一阶段动员群众破坏旧秩序的造反大方向。经过1966年8月、9月的大字报、大鸣、大放、大辩论，保工作组的保守派群众组织与反工作组的造反派群众组织，已阵线分明，发展到互不兼容、激烈对抗的局面。1966年9月23日，地院东方红与保守派组织斗批改兵团，为争夺学院广播台的控制权发生的肢体冲突，被视为文革运动中发生在北京高校的第一次武斗事件。时任北京新市委第二书记吴德，根据周总理的指示，首先赶到北京地院处理这一事件。但吴德依据周总理的指示不能平息事件，无法摆平双方的对立冲突。吴德说：“这是周总理的指示，但他们根本不听。”随后中央文革组长陈伯达亦派关锋、戚本禹到地院处理这一事件。 在地院现场，吴德向戚本禹传达周总理指示后，戚本禹说：“这个办法不行，你们要支持‘东方红’，他们是左派，中央文革小组支持他们。”随后有林彪1966年国庆讲话，《红旗》十三期社论发表，十月中央工作会议召开，掀起全国性的批判资产阶级反动路线运动高潮。保守派组织迅速瓦解，反工作组造反派迅速发展壮大，成为多数派。依靠发展左派队伍，瓦解保守派组织，团结大多数群众，向刘少奇掌控一线建立与运作的权力系统造反，成为当时毛泽东处理文革运动中分裂与对立的各派群众组织的方针、政策。地院东方红也随之成为这一时段北京高校文革运动中造反冲杀出来的新典型、新领头羊。王大宾代表地院东方红，被毛泽东视为北京五大学生领袖之一，是真实反映了地院东方红、“首都三司”在文革运动破坏旧秩序阶段中的地位与影响的。《王大宾回忆录》记述的这一史实，值得研究者进一步深入展开，以更完整地还原文革运动历史的真相。 在许多记述北京文革运动的书中、文章中，都会拿北京高校造反派组织1967年后所谓“天派”、“地派”之分，所谓“天派”与“地派”的斗争说事。据我了解，被视为“天派”代表人物之一的北航红旗负责人韩爱晶，与视为“地派”代表人物之一的地院东方红负责人王大宾，他们都不承认北京有因一个焦点矛盾而对立分裂的有组织的天派、地派。《王大宾回忆录》中对这一认识表述了他的观点。我认为是符合当年北京高校文革运动真实情况的。 1967年，文革运动已进入毛泽东建立新秩序的新阶段。争夺在新秩序、新的权力系统中的地位与影响，主要表现为军队、干部与群众组织三者之间的博弈。分歧、冲突、对立已不像第一阶段那样两军对垒，阵线分明，左派、保守派已难以认定判断。毛泽东为了实现第二阶段建立新秩序、建立新的权力系统的战略目标，必须面对现实，权衡利弊。面对周恩来支持的老帅，副总理们在1967年2月，代表干部群体表达的强烈不满情绪，虽大为震怒，亦不能不最后妥协，示出团结的善意，并发社论宣示正确对待干部的方针。还发表《红旗》评论员文章，将打击干部一大片的过错，加之于刘少奇代表的资产阶级反动路线。面对武汉群众组织百万雄师在军队支持下，表现出对王力公开讲话宣布、而实为毛泽东所决定的处理武汉问题方针的激烈反抗，毛泽东决定改变过往处理文革运动中分裂与对立的各派群众组织、依靠发展左派队伍团结大多数群众的方针，以工人阶级内部没有根本的利害冲突的平等大联合的方针取而代之。毛泽东同时批判了“揪军内一小撮”斗争方向，果断处理了王力、关锋等人，稳定化解了军队的不满情绪。当年，王大宾对毛泽东文革运动战略阶段与战略方针、部署的转换，是认识不清楚的，头脑膨胀、犯错误是必然的。毛泽东1968年7月28日召见“五大学生领袖”谈话中，批评造反派组织多中心即无中心表现，认定山头林立的众多造反派组织，已发展到谁的话也不听，实已成为了建立新秩序的阻碍，起了破坏作用。《王大宾回忆录》正是依据这样的认识，反思1967年后，北京高校反工作组造反派组织之间发生的个别冲突事件，反思地院东方红与北大新北大公社之间1967年4月发生的民族文化宫展览问题上的冲突。王大宾后来主张东方红应专注学院运动，不要介入外单位运动的想法应是好的，但在当时的形势下，他亦骑虎难下，无法掌控。王大宾对毛泽东1968年7月28日，召见他们五大学生领袖的谈话有他自己的反思，也认识到文革运动的实践证明自己不行，最终被毛泽东“不要”是必然的。对此，回忆录中有较为明白的理解与评述，亦值得亲历过文革运动那段历史的人们和研究者深思。 以孔丹为头的“西纠”在成立之初，即在地院东方红到地质部机关上访请愿时，就彼此发生严重的对立与冲突。事过近50年，孔丹在回忆录《难得本色任天然》中，表明他们这些老红卫兵，“和老干部有着天然的联系”的人，与地院东方红王大宾这样的反工作组造反派，“具有本质的区别”。王大宾在回忆录中批评了孔丹的这一说法，认为其骨子里还是根深蒂固的“老子英雄儿好汉”的血统论，左右他的思维与判断。不知孔丹能否接受对他的这一思想的评说与批评。因为他在书中表白，当年他是不同意“老子英雄儿好汉，老子反动儿混蛋”这一狂热鼓吹封建血统论的对联的。 然而，孔丹的认识与想法，可以影响到上层的政策，区别对待处理同样参与文革运动同样事件的人。《王大宾回忆录》记述了他为何取代朱成昭，由二把手变成了地院东方红的一把手。叶剑英对文革运动的态度，如何通过其女儿叶向真影响到朱成昭，成为他从听从中央文革转向对它的怀疑、批评的主要动因。叶向真与朱成昭等人，后虽同被打成“叶、朱反革命集团”，关进监狱，但终局却有完全不同的人生命运与结局！王大宾感慨评说：“有人对《西游记》的评论说得好：有背景的妖怪都被收走了，没有背景的妖怪就被孙悟空打死了！” 王大宾对朱成昭人生命运的感慨，亦是对自己人生命运的感叹。文革运动中，能打上王大宾个人印记的大事件，应只有奉命参与并负责把彭德怀元帅从成都揪回北京这件事了。《回忆录》详述了王大宾参与这一事件的过程与细节，澄清了过往许多书籍文章关于这件事的不实、不全的描述，还原了历史真相，是《王大宾回忆录》的一大看点。在这一事件中，王大宾一方面在与彭德怀的接触交谈中，同情彭德怀的处境，并在认识上产生共鸣，为此不同意中央揪彭决定，派人到北京向中央文革小组汇报，申述他们的意见，但却遭到批评；另一方面，最终执行了周恩来和中央文革小组的指示，和成都军区派出干部一起，负责带领地院东方红的战士，把彭德怀安全护送到了北京。这两方面的事实，都是当年的客观存在，王大宾不能否定，他也从未否定。但令王大宾不理解的是，出于政治的需要，可以对同时存在的客观事实，选择性地认定、采信，并据此作出惩罚。在巩固文革运动新秩序的阶段，曾经发动了清查“5•16分子”的运动，王大宾被认定为同情彭德怀，抗拒执行中央从成都揪回彭德怀的决定，据此指控为王大宾的主要罪行，将其打成“5•16分子”，未经任何法律程序，剥夺王大宾的人身自由，关押审查四年之久。而至文革运动结束后的1978年，又将王大宾逮捕关押五年，至1983年8月18日，根据陈云“怎么只判天派？地派也要判！”的指示，武汉市中级人民法院作出刑事判决，指控“王大宾在一九六六年十二月至一九六八年八月期间，积极追随林彪、江青反革命集团进行犯罪活动”，王大宾被认定的主要“罪行”，就是王大宾带领地院部分学生，将彭德怀挟持，押到北京，“使彭德怀同志人身遭到迫害”。为此，王大宾被判处有期徒刑九年，剥夺政治权利三年。面对完全不适用1979年7月6日颁布、1980年1月11日生效实施的《中华人民共和国刑法》相关规定的审判，王大宾只能感叹：“当时的我能说什么呢？这就是政治。”]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>季羡林</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议面试知识点总结]]></title>
    <url>%2F2017%2F09%2F03%2Fhttp%E5%8D%8F%E8%AE%AE%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近在看面经的时候，发现大部分的公司面试的时候都会问到http协议，大部分的博客写的不是很系统，所以决定自己写一篇。 统一资源定位符URL在说HTTP协议之前必须要先了解URL（统一资源定位符）统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。基本URL包含模式（或称协议）、服务器名称（或IP地址）、路径和文件名，如“协议://授权/路径?查询”。完整的、带有授权部分的普通统一资源标志符语法看上去如下：协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志 第一部分 模式/协议（scheme）：它告诉浏览器如何处理将要打开的文件。最常用的模式是超文本传输协议（Hypertext Transfer Protocol，缩写为HTTP），这个协议可以用来访问网络。其他协议如下： http——超文本传输协议资源 https——用安全套接字层传送的超文本传输协议 ftp——文件传输协议 mailto——电子邮件地址 ldap——轻型目录访问协议搜索 file——当地电脑或网上分享的文件 news——Usenet新闻组 gopher——Gopher协议 telnet——Telnet协议 第二部分 文件所在的服务器的名称或IP地址，后面是到达这个文件的路径和文件本身的名称。服务器的名称或IP地址后面有时还跟一个冒号和一个端口号。它也可以包含接触服务器必须的用户名称和密码。路径部分包含等级结构的路径定义，一般来说不同部分之间以斜线（/）分隔。询问部分一般用来传送对服务器上的数据库进行动态询问时所需要的参数。 超文本传送协议HTTPHTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。 HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。 HTTP协议是OSI模型中的第七层应用程中协议具有以下特点： 1、支持客户/服务器模式; 2、简单快速; 3、灵活; 4、无连接; 5、无状态； 给一个简单的实例来看看http协议的执行过程上图中用户点击了一个链接指向清华大学院系设置的页面，其URL是http://www.tsinghua.edu.cn/chn/yxsz/index.htm用http/1.0更具体的说明用户在点击鼠标后发生的事件： （1）浏览器分析链接指向页面的URL。 （2）浏览器向DNS请求解析http://www.tsinghua.edu.cn的IP地址。 （3）域名系统DNS解析出清华大学的IP地址为166.111.4.100。 （4）浏览器与服务器建立TCP连接（服务器的IP地址是166.111.4.100，端口号是80）。 （5）浏览器发出取文件命令：GET/chn/yxsz/index.htm。 （6）服务器http://www.tsinghua.edu.cn做出响应，把文件index.htm发送给浏览器。 （7）释放TCP连接。 （8）浏览器显示“清华大学院系设置”文件index.htm中的所有文件。 浏览器在下载文件时，可以设置为只下载其中的文本部分。这样可使下载的速度加快。在这种情况下，文本中原来嵌入图像或声音的地方只用一个小图标来显示。用户若要下载这些图像或声音，可再用鼠标分别点击这些图标。每点击一次鼠标就重复执行一次类似于上面的8个步骤。也就是先建立TCP连接，再使用TCP连接传送命令和文件，最后释放TCP连接。 HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。 HTTP是无连接的无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端(即浏览器)与服务器之间交换数据的间歇性较大(即传输具有突发性、瞬时性)，并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。 HTTP是无状态的无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。HTTP 是一个无状态协议，这意味着每个请求都是独立的。 缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。 一次HTTP过程 如上图用户点击某个万维网文档连接时，HTTP协议首先要和服务器建立TCP连接。这是需要三次握手。当三次握手的前两部分完成后（经过了一个RTT时间后），万维网客户就把HTTP请求报文作为第三次握手的第三个报文的数据发送给万维网服务器。万维网服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。 HTTP/1.0协议的缺点HTTP的主要缺点，就是每请求一个文档就要两倍RTT的开销。若一个主页上有很多链接的对象（如图片等）需要一次进行链接，那么每一次链接下载都导致2RTT的开销。另一种开销就是万维网客户和服务器没一次建立新的TCP连接都要分配缓存和变量。 HTTP/1.1协议较好的解决了上面的问题，它使用持续连接。在万维网服务器发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。并且不限于传送同一个页面上链接的文档，而是只要这些文档都在一个服务器上就行。 HTTP/1.1协议的持续连接有两种方式，即非流水线方式和流水线方式。 HTTP的报文结构HTTP有两类报文： （1）请求报文—–从客户端向服务器发送请求报文。（2）响应报文—–从服务器到客户的回答。 请求报文的结构如下图： 响应报文的结构如下图： HTTP请求报文和响应报文都是由三个部分组成。可以看出这两种报文的区别就在于开始行不同。（1）开始行，用于区别是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行就叫做状态行。（2）首部行，用于说明浏览器、服务器、或报文主体的一些信息。首部可以有好几行，但也可以不用。（3）实体主体，在请求报文中一般不用这个字段，在响应报文中返回请求的内容，也可以不用。 请求报文的第一行“请求行”只有三个内容，方法，请求资源的URL，以及HTTP的版本。这里的方法是对请求的对象进行的操作，这些方法实际上也就是一些命令，请求报文的类型就是由它采用的方法决定的。 HTTP的请求方法 1、OPTIONS返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性 2、HEAD向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。 3、GET向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。 4、POST向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 5、PUT向指定资源位置上传其最新内容 6、DELETE请求服务器删除Request-URL所标识的资源 7、TRACE回显服务器收到的请求，主要用于测试或诊断 8、CONNECTHTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 GET和POST的比较GET - 从指定的服务器中获取数据 POST - 提交数据给指定的服务器处理 GET方法： 使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：/test/demo_form.jsp?name1=value1&amp;name2=value2 特点： （1）GET请求能够被缓存 （2）GET请求会保存在浏览器的浏览记录中 （3）以GET请求的URL能够保存为浏览器书签 （4）GET请求有长度限制 （5）GET请求主要用以获取数据 POST方法： 使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：POST /test/demo_form.jspHTTP/1.1 Host: w3schools.comname1=value1&amp;name2=value2 特点： （1）POST请求不能被缓存下来（2）POST请求不会保存在浏览器浏览记录中（3）以POST请求的URL无法保存为浏览器书签（4）POST请求没有长度限制 HTTP状态码HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。每一个请求报文发出后，都能收到一个响应报文。响应报文的第一行就是状态行。状态行包含三项内容，HTTP的版本、状态码、以及解释状态码的简单短语。状态码共分为5大类33种。如： 下面是在状态行中常见的状态码： 100 Continue 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 Accepted 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 300 Multiple Choices 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 400 Bad Request 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 HTTP与HTTPS的区别到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而 HTTP 并非只有好的一面，事物皆具两面性，HTTP 也是有不足之处的。 1、通信使用明文（ 不加密） ， 内容可能会被窃听 2、不验证通信方的身份， 因此有可能遭遇伪装 3、无法证明报文的完整性， 所以有可能已遭篡改 通信使用明文可能会被窃听由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。 HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。 1、无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。 2、无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。 3、无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息， 只想发给特定用户通信的权限。 4、无法判定请求是来自何方、出自谁手。 5、即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS 攻击（ Denial of Service， 拒绝服务攻击） 。 确保 Web 安全的 HTTPS 在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。HTTP+ 加密 + 认证 + 完整性保护 =HTTPS HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS （HTTP Secure）。 参考文献1、计算机网络第五版（谢希仁）2、TCP/IP协议详解卷13、http://www.cnblogs.com/zxj015/p/6530766.html]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>超文本传输协议资源</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--DNS完全解析]]></title>
    <url>%2F2017%2F07%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-DNS%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言前几天，因为要申请一个VR方面的专利在网上找参考资料，准备基于Oculus的sdk进行二次开发。突然发现进不了Oculus的官方网站，后面发现是电脑网络设置中的DNS在作妖。最近几天正好看计算机网络的方面的书，就抽时间把DNS总结一下。 DNS的作用TCP／IP网络中要求每一个互连的计算机都具有其唯一的IP地址，并基于这个IP地址进行通信。由于IP地址是有一串数字组成不好记，因此为每一台计算机赋唯一的主机名，用户可以用要通讯计算机或服务器的主机名而无需直接用IP地址进行通信。但在网络层必须使用IP地址进行，因此域名系统DNS（Domain Name System）是因特网使用的命名系统，用于把便于人们使用的主机名字（如baidu.com）转换为ｉｐ地址。计算机中ｃ盘下会存一个叫做hosts的数据库文件，如下图： 域名解析器 进行域名查询的主机和软件叫做域名解析器。用户使用的工作站或电脑都属于解析器，当某个应用进程要把主机名解析为IP地址使，比如访问（baidu.com）时，就会调用域名解析程序，域名解析程序先访问本地的hosts数据库，大部分的域名解析都在本地进行，如果hosts里面有主机名与对应的IP地址则返回该IP地址。只有hosts里面没有的才会把待解析的域名放在DNS请求报文中以UDP用户报的形式发给本地域名解析器，本地域名解析器在查找域名后，把对应的IP地址放在回答报文中返回，应用进程获得目的的主机IP地址后就可以进行通信。若本地域名服务器不能回答该请求，则此域名服务器暂时成为DNS中的另一个客户，并向其他域名服务器发出查询请求。这个过程直到找到能够回答该请求的域名服务器为止。 域名的构成域名是指为了识别主机名称和组织机构名称而采用的一种具有分层的名称。例如，华中科技大学的域名如下：hust.edu.cn 最左边的 hust 表示华中科技大学，edu表示教育机构，cn表示中国。dns的分层如下图所示： 域名服务器域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。其所管理的分层叫做ZONE。如下图所示每一层都有一个域名服务器： 由上图可以得出以下三点结论 ① 各个域的分层上都有各自的域名服务器 ②各层域名服务器都了解该层一下分层中所有域名服务器的IP地址。因此它们从根节点开始呈树状结构相互连接。 ③由于所有域名服务器都了解根域名服务器的IP地址，所以若从根开始按顺序追踪，可以访问世界上所有域名服务器的地址。 根域名服务器：根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析（转换为IP地址），只要自己无法解析，就首先要求助于根域名服务器。 DNS查询 域名的查询过程注意两点：①主机向本地域名服务器的查询采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文，而不是让主机自己进行下一步查询。因此，递归查询返回的结果或者是要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。 ②本地域名服务器向根域名服务器的查询通常采用迭代查询。迭代查询的特点是这样的：当根域名服务器收到本地域名服务器发出的迭代查询请求报文是，要么给出所要查询的IP地址，要么告诉域名服务器下一步要向哪个域名服务器进行查询。然后本地域名服务器继续进行下一步查询。 总结其实弄懂DNS主要弄懂两点：①域名解析器 ②域名服务器 参考文献1.计算机网络（第五版）–谢希仁2.图解TCP/IP（第五版）–冈本3.TCP/IP详解4.https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划 Dynamic Programming--从菜鸟到老鸟]]></title>
    <url>%2F2017%2F07%2F15%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming-%E4%BB%8E%E8%8F%9C%E9%B8%9F%E5%88%B0%E8%80%81%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[前言最近在牛客网上做了几套公司的真题，发现有关动态规划（Dynamic Programming）算法的题目很多。相对于我来说，算法里面遇到的问题里面感觉最难的也就是动态规划（Dynamic Programming）算法了，于是花了好长时间，查找了相关的文献和资料准备彻底的理解动态规划（Dynamic Programming）算法。一是帮助自己总结知识点，二是也能够帮助他人更好的理解这个算法。后面的参考文献只是我看到的文献的一部分。 动态规划算法的核心理解一个算法就要理解一个算法的核心，动态规划算法的核心是下面的一张图片和一个小故事。 1234567891011A * &quot;1+1+1+1+1+1+1+1 =？&quot; *A : &quot;上面等式的值是多少&quot;B : *计算* &quot;8!&quot;A *在上面等式的左边写上 &quot;1+&quot; *A : &quot;此时等式的值为多少&quot;B : *quickly* &quot;9!&quot;A : &quot;你怎么这么快就知道答案了&quot;A : &quot;只要在8的基础上加1就行了&quot;A : &quot;所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 &apos;记住求过的解来节省时间&apos;&quot; 由上面的图片和小故事可以知道动态规划算法的核心就是记住已经解决过的子问题的解。 动态规划算法的两种形式上面已经知道动态规划算法的核心是记住已经求过的解，记住求解的方式有两种：①自顶向下的备忘录法 ②自底向上。为了说明动态规划的这两种方法，举一个最简单的例子：求斐波拉契数列Fibonacci 。先看一下这个问题： 12345Fibonacci (n) = 1; n = 0Fibonacci (n) = 1; n = 1Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2) 以前学c语言的时候写过这个算法使用递归十分的简单。先使用递归版本来实现这个算法：12345678910public int fib(int n)&#123; if(n&lt;=0) return 0; if(n==1) return 1; return fib( n-1)+fib(n-2);&#125;//输入6//输出：8 先来分析一下递归算法的执行流程，假如输入6，那么执行的递归树如下： 上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行，fib(2)被重复执行了5次。由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把执行过的子节点保存起来，后面要用到的时候直接查表调用的话可以节约大量的时间。下面就看看动态规划的两种方法怎样来解决斐波拉契数列Fibonacci 数列问题。 ①自顶向下的备忘录法12345678910111213141516171819202122public static int Fibonacci(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; for(int i=0;i&lt;=n;i++) Memo[i]=-1; return fib(n, Memo); &#125; public static int fib(int n,int []Memo) &#123; if(Memo[n]!=-1) return Memo[n]; //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。 if(n&lt;=2) Memo[n]=1; else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo); return Memo[n]; &#125; 备忘录法也是比较好理解的，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。比如上面的递归树中在计算fib（6）的时候先计算fib（5），调用fib（5）算出了fib（4）后，fib（6）再调用fib（4）就不会在递归fib（4）的子树了，因为fib（4）的值已经保存在Memo[4]中。 ②自底向上的动态规划备忘录法还是利用了递归，上面算法不管怎样，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）……,那么何不先计算出fib（1），fib（2），fib（3）……,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。 12345678910111213public static int fib(int n)&#123; if(n&lt;=0) return n; int []Memo=new int[n+1]; Memo[0]=0; Memo[1]=1; for(int i=2;i&lt;=n;i++) &#123; Memo[i]=Memo[i-1]+Memo[i-2]; &#125; return Memo[n];&#125; 自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。观察参与循环的只有 i，i-1 , i-2三项，因此该方法的空间可以进一步的压缩如下。 12345678910111213141516public static int fib(int n) &#123; if(n&lt;=1) return n; int Memo_i_2=0; int Memo_i_1=1; int Memo_i=1; for(int i=2;i&lt;=n;i++) &#123; Memo_i=Memo_i_2+Memo_i_1; Memo_i_2=Memo_i_1; Memo_i_1=Memo_i; &#125; return Memo_i; &#125; 一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。你以为看懂了上面的例子就懂得了动态规划吗？那就too young too simple了。动态规划远远不止如此简单，下面先给出一个例子看看能否独立完成。然后再对动态规划的其他特性进行分析。 动态规划小试牛刀例题：钢条切割 上面的例题来自于算法导论关于题目的讲解就直接截图算法导论书上了这里就不展开讲。现在使用一下前面讲到三种方法来来实现一下。①递归版本1234567891011public static int cut(int []p,int n) &#123; if(n==0) return 0; int q=Integer.MIN_VALUE; for(int i=1;i&lt;=n;i++) &#123; q=Math.max(q, p[i-1]+cut(p, n-i)); &#125; return q; &#125; 递归很好理解，如果不懂可以看上面的讲解，递归的思路其实和回溯法是一样的，遍历所有解空间但这里和上面斐波拉契数列的不同之处在于，在每一层上都进行了一次最优解的选择，q=Math.max(q, p[i-1]+cut(p, n-i));这个段语句就是最优解选择，这里上一层的最优解与下一层的最优解相关。 ②备忘录版本 12345678910111213141516171819202122public static int cutMemo(int []p) &#123; int []r=new int[p.length+1]; for(int i=0;i&lt;=p.length;i++) r[i]=-1; return cut(p, p.length, r); &#125; public static int cut(int []p,int n,int []r) &#123; int q=-1; if(r[n]&gt;=0) return r[n]; if(n==0) q=0; else &#123; for(int i=1;i&lt;=n;i++) q=Math.max(q, cut(p, n-i,r)+p[i-1]); &#125; r[n]=q; return q; &#125; 有了上面求斐波拉契数列的基础，理解备忘录方法也就不难了。备忘录方法无非是在递归的时候记录下已经调用过的子函数的值。这道钢条切割问题的经典之处在于自底向上的动态规划问题的处理，理解了这个也就理解了动态规划的精髓。 ③自底向上的动态规划 12345678910111213public static int buttom_up_cut(int []p) &#123; int []r=new int[p.length+1]; for(int i=1;i&lt;=p.length;i++) &#123; int q=-1; //① for(int j=1;j&lt;=i;j++) q=Math.max(q, p[j-1]+r[i-j]); r[i]=q; &#125; return r[p.length]; &#125; 自底向上的动态规划问题中最重要的是理解注释①处的循环，这里外面的循环是求r[1],r[2]……，里面的循环是求出r[1],r[2]……的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。下面是长度为4的钢条划分的结构图。我就偷懒截了个图。 动态规划原理虽然已经用动态规划方法解决了上面两个问题，但是大家可能还跟我一样并不知道什么时候要用到动态规划。总结一下上面的斐波拉契数列和钢条切割问题，发现两个问题都涉及到了重叠子问题，和最优子结构。 ①最优子结构 用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。 ②重叠子问题 在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。 动态规划的经典模型线性模型线性模型的是动态规划中最常用的模型，上文讲到的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。【例题1】是一个经典的面试题，我们将它作为线性模型的敲门砖。 【例题1】在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。 每次过桥的时候最多两个人，如果桥这边还有人，那么还得回来一个人（送手电筒），也就是说N个人过桥的次数为2*N-3（倒推，当桥这边只剩两个人时只需要一次，三个人的情况为来回一次后加上两个人的情况…）。有一个人需要来回跑，将手电筒送回来（也许不是同一个人，realy？！）这个回来的时间是没办法省去的，并且回来的次数也是确定的，为N-2，如果是我，我会选择让跑的最快的人来干这件事情，但是我错了…如果总是跑得最快的人跑回来的话，那么他在每次别人过桥的时候一定得跟过去，于是就变成就是很简单的问题了，花费的总时间： T = minPTime * (N-2) + (totalSum-minPTime) 来看一组数据 四个人过桥花费的时间分别为 1 2 5 10，按照上面的公式答案是19，但是实际答案应该是17。 具体步骤是这样的： 第一步：1和2过去，花费时间2，然后1回来（花费时间1）； 第二歩：3和4过去，花费时间10，然后2回来（花费时间2）； 第三部：1和2过去，花费时间2，总耗时17。 所以之前的贪心想法是不对的。我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i] (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2a[2] (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2a[2] } 区间模型区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。 【例题2】给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。典型的区间模型，回文串拥有很明显的子结构特征，即当字符串X是一个回文串时，在X两边各添加一个字符’a’后，aXa仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有 d[i][j] = d[i+1][j-1] （这里需要明确一点，当i+1 &gt; j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策： 1、在A[j]后面添加一个字符A[i]； 2、在A[i]前面添加一个字符A[j]； 根据两种决策列出状态转移方程为： d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1; (每次状态转移，区间长度增加1) 空间复杂度O(n^2)，时间复杂度O(n^2)， 下文会提到将空间复杂度降为O(n)的优化算法。 背包模型背包问题是动态规划中一个最典型的问题之一。由于网上有非常详尽的背包讲解，这里只将常用部分抽出来。 【例题3】有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为： f[i][v] = max{ f[i-1][v], f[i-1][v – Ci] +Wi } 时间复杂度O(VN)，空间复杂度O(VN) （空间复杂度可利用滚动数组进行优化达到O(V) ）。 动态规划题集整理1、最长单调子序列Constructing Roads In JG Kingdom★★☆☆☆Stock Exchange ★★☆☆☆ 2、最大M子段和Max Sum ★☆☆☆☆最长公共子串 ★★☆☆☆ 3、线性模型 Skiing ★☆☆☆☆ 总结弄懂动态规划问题的基本原理和动态规划问题的几个常见的模型，对于解决大部分的问题已经足够了。希望能对大家有所帮助，转载请标明出处http://write.blog.csdn.net/mdeditor#!postId=75193592，创作实在不容易，这篇博客花了我将近一个星期的时间。 参考文献1.算法导论]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--深入理解ArrayList实现原理]]></title>
    <url>%2F2017%2F05%2F19%2FJava%E8%BF%9B%E9%98%B6-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ArrayList简介ArrayList就是动态数组，用MSDN中的说法，就是Array的复杂版本，它提供了动态的增加和减少元素，实现了Collection和List接口，可以灵活的设置数组的大小。要注意的是ArrayList并不是线程安全的，因此一般建议在单线程中使用ArrayList。 ArrayList的继承关系123public class ArrayList&lt;E&gt;extends AbstractList&lt;E&gt;implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable 由上可知ArrayList继承AbstractList 并且实现了List和RandomAccess，Cloneable, Serializable接口。 ArrayList的方法使用和源码解析①构造方法 1234567891011121314151617181920212223//1-----------------------public ArrayList() &#123; this(10); //调用ArrayList(10) 默认初始化一个大小为10的object数组。 &#125; //2-------------------------public ArrayList(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); //如果用户初始化大小小于0抛异常，否则新建一个用户初始值大小的object数组。 this.elementData = new Object[initialCapacity]; &#125; //3--------------------------public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // 当c.toArray返回的不是object类型的数组时，进行下面转化。 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; 由上面三种构造方法可知，默认情况下使用ArrayList会生成一个大小为10的Object类型的数组。也可以调用ArrayList(int initialCapacity) 来初始化Object数组的大小。并且用户可以往ArrayList中传入一个容器只要这个容器是Collection类型的。调用ArrayList(Collection&lt;? extends E&gt; c)接口的时候会将容器数组化处理并将这个数组值赋给Object数组。 实例： 1234567891011121314151617181920public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list_2=new ArrayList&lt;Integer&gt;(20); //list_2中添加元素 for(int i=0;i&lt;10;i++) list_2.add(i); ArrayList&lt;Integer&gt; list_3=new ArrayList&lt;Integer&gt;(list_2); //输出list_2中元素 for(Integer a:list_2) System.out.print(a+&quot; &quot;); //输出list_3中元素 for(Integer a:list_3) System.out.print(a+&quot; &quot;); &#125;//输出/*list_2 : 0 1 2 3 4 5 6 7 8 9 -----------------------list_3 : 0 1 2 3 4 5 6 7 8 9 */ ②indexOf(Object o)方法功能：查找某个元素在ArrayList中第一次出现的位置。123456789101112131415public int indexOf(Object o) &#123;//ArrayList中的元素可以为null，如果为null返回null的下标 if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; //如果没有找到对应的元素返回-1。 return -1; &#125; 对于indexof方法做几点说明：ArrayList中可以存放null元素，indexof是返回elementData数组中值相同的首个元素的下标，indexof中比较方法是equals而equals是比较元素的值，因此必须对null单独查找。如果未找到该元素则返回-1 。 12345678910111213141516171819202122232425public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2); list.add(null); list.add(2); list.add(3); System.out.println(&quot;null: &quot;+list.indexOf(null)); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;2: &quot;+list.indexOf(2)); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;4: &quot;+list.indexOf(4)); &#125; //输出 /* null: 2 ------------------------- 2: 1 ------------------------- 4: -1 */ ③lastIndexOf(Object o)方法功能：查找某个元素在ArrayList中最后出现的位置。1234567891011121314public int lastIndexOf(Object o) &#123; if (o == null) &#123; //如果o为null从后往前找到第一个为null的下标 for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; //从后往前找到第一个值为o的下标 for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 上面代码做几点说明：lastIndexOf(Object o)在ArrayList中从后往前找到第一个跟要查找值相同的元素的下标，因为是按值查找所以对于 null 要单独查找。如果未找到则返回-1； ④get(int index)方法功能：返回ArrayList中指定下标为index的元素。 123456789101112131415public E get(int index) &#123; //检查index的值是否大于ArrayList的大小 rangeCheck(index); //返回index下标的元素 return elementData(index); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125; //这里值检查index &gt;= size的情况，因为index&lt;0时会自动抛出异常，所以并未检查index&lt;0的情况。 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 对上面代码做几点说明：上面代码中只检查了index&gt;=size的情况，在index=size要检查的原因是有可能数组的大小大于index，然而有效里面的元素&lt;index这时不抛异常就会返回无效值。举个例子ArrayList的初始化大小为10，现在往里面放5个元素，如果index&gt;=5时，应该要抛出异常，而不是返回 null。因为null 是可以主动放在ArrayList中的。 ⑤set(int index, E element)方法功能：将element放到ArrayList下标为index的位置，如果index=size 抛异常，set(int index, E element)只能覆盖ArrayList中原来的元素，返回值为被覆盖的元素。 123456789101112131415//1public E set(int index, E element) &#123;//检查index是否小于size，如果不是抛异常 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //覆盖ArrayList中index上的元素。 return oldValue; //返回被覆盖的元素。 &#125;//2 private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; ⑥add(E e)方法功能：往ArrayList中添加元素。 12345678910111213141516171819202122232425262728//1-----------------------public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 加入元素前检查数组的容量是否足够 elementData[size++] = e; return true; &#125;//2----------------------- private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // 如果添加元素后大于当前数组的长度，则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //3----------------------- private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //将数组的长度增加原来数组的一半。 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果扩充一半后仍然不够，则 newCapacity = minCapacity;minCapacity实际元素的个数。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //数组最大位2^32 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; add方法比较复杂，涉及到扩充数组容量的问题。其中要弄清楚size和elementData.length的区别，size指的是数组中存放元素的个数，elementData.length表示数组的长度，当new一个ArrayList系统默认产生一个长度为10的elementData数组，elementData.length=10，但是由于elementData中还未放任何元素所有size=0。如果加入元素后数组大小不够会先进行扩容，每次扩容都将数组大小增大一半比如数组大小为10一次扩容后的大小为10+5=10;ArrayList的最大长度为 2^32 . ⑦add(int index, E element)方法功能：往ArrayList指定index上添加元素，添加元素后ArrayList的大小增1。index及以后的元素都会向后移一位。 1234567891011121314151617181920212223//1-------------------------public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index的值是否在0到size之间，可以为size。 ensureCapacityInternal(size + 1); // 看elementData的长度是否足够，不够扩容 //将elementData从index开始后面的元素往后移一位。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;//2-------------------------private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; //3------------------------- private void ensureCapacityInternal(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; add(int index, E element)往指定index中加入元素，加入元素之前先检查数组的大小，如果小了在原来基础上增大一半，将ArrayList只能怪index及以后的元素往后移一位，将element放到index位置。 ⑧remove(int index)方法功能：删除ArrayList指定位置的元素。123456789101112131415public E remove(int index) &#123; rangeCheck(index);//如果index&gt;=size抛出异常 modCount++; E oldValue = elementData(index);//获取删除元素的值 int numMoved = size - index - 1; //将index后面所有的元素往前移一位。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work//返回要删除的原数。 return oldValue; &#125; ⑨remove(Object o)方法功能：删除ArrayList中值为o的元素 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;]]></content>
      <tags>
        <tag>ArrayList</tag>
        <tag>实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--从源码理解Integer类的toString方法]]></title>
    <url>%2F2017%2F05%2F15%2FJava%E8%BF%9B%E9%98%B6-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3Integer%E7%B1%BB%E7%9A%84toString%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java中的jdk是深入学习Java编程的宝库，其中各种方法的实现不仅可以深入了解 设计模式的应用，还可以看到jdk编写者如何优化代码（这种优化已经到达了一种极端的程度）对我们编写自己的代码是有十分重要的作用的。read the fucking source code 是成为一名优秀程序猿必须的经历。本博客通过分析Integer类的toString方法来看看jdk编写者如何编写他们的代码的。 Integer类的toString的基本用法12345678910111213141516171819202122232425262728293031323334353637383940public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer OUT_MAX_VALUE=new Integer(Integer.MAX_VALUE+1); Integer MAX_VALUE=new Integer(Integer.MAX_VALUE); Integer MIN_VALUE=new Integer(Integer.MIN_VALUE); Integer NOR_VALUE=new Integer(-128); Integer OUT_MIN_VALUE=new Integer(Integer.MIN_VALUE-1); System.out.println(&quot;max_val :&quot;+MAX_VALUE.toString()); System.out.println(&quot;max_val :&quot;+MAX_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;out_max :&quot;+OUT_MAX_VALUE.toString()); System.out.println(&quot;out_min :&quot;+OUT_MIN_VALUE.toString()); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;min_val :&quot;+MIN_VALUE.toString()); System.out.println(&quot;min_val :&quot;+MIN_VALUE); System.out.println(&quot;-------------------------&quot;); System.out.println(&quot;nor_val :&quot;+NOR_VALUE.toString()); System.out.println(&quot;nor_val :&quot;+NOR_VALUE); &#125;&#125;//输出/*max_val :2147483647max_val :2147483647-------------------------out_max :-2147483648out_min :2147483647-------------------------min_val :-2147483648min_val :-2147483648-------------------------nor_val :-128nor_val :-128*/ 由上面可知直接输出Integer的值和调用Integer类的toString方法是一样的，其实直接打印一个对象的时候就是调用了该对象的toString方法。调用toString方法的时候其实输出的是Integer的value值，toString方法就是把int类型的value值转化为string类型输出。注意一下几点： ①Integer的value值从 Integer.MIN_VALUE 到 Integer.MAX_VALUE 如果超出了这个范围就会得到一些奇怪的结果。 ②在Integer.MAX_VALUE基础上加1输出的结果是个负值。 ③在Integer.MIN_VALUE基础上加1输出的结果是个正值。 Integer类的toString的源码分析下面就深入看看Integer类的toString方法是如何实现的。还是直接上源码。 123456789101112131415161718192021 public String toString() &#123; return toString(value); &#125;//------------------------------ public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return &quot;-2147483648&quot;; //如果是最小值直接返回其字符串因为Integer.MIN_VALUE=-2147483648 ，这样可以节省下面计算时间 //① int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); //获取整数值的长度10进制 char[] buf = new char[size]; //② getChars(i, size, buf); //得到整数中的每一个字符 //③ return new String(buf, true); //返回字符串值 &#125; 上面的代码做几点说明：①如果Integer的value值正好是 Integer.MIN_VALUE 直接返回 “-2147483648” 节省时间。②得到integer值的十进制的长度，如果负数先求出绝对值的长度，然后再长度加1，因为负数的符号位占一位。③得到integer的value值的每一个字符。④得到的字符新建字符串返回。下面看看 stringSize方法是怎样实现的： 123456789 static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1; //看看x到底是几位数 &#125;//----------------------------------final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;; 上面的 stringSize 非常的巧妙的来整数的长度，首先定义了一个数组这个数组中分别存放了一位十进制的最大值，二位十进制的最大值，依次到 Integer.MAX_VALUE为止，因为integer的最大值为 Integer.MAX_VALUE，也就是说integer的最大长度为10位。注意：①stringSize(int x) 中的参数x 必须是正整数。下面用一个实例看看stringSize(int x)方法。 1234567891011121314151617181920212223242526272829303132public class IntegerDemo &#123; public static void main(String[] args) &#123; int x=199; int max=Integer.MAX_VALUE; int out_max=Integer.MAX_VALUE+1; System.out.println(stringSize(x)); System.out.println(&quot;-------------------------&quot;); System.out.println(stringSize(max)); System.out.println(&quot;-------------------------&quot;); System.out.println(stringSize(out_max)); &#125; final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;; static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1; &#125;&#125;//输出/*3-------------------------10-------------------------1*/ 上面的199小于999所以位数为3，而 out_max的值因为超过了 Integer.MAX_VALUE是个负数，得到的长度为1，因此求负数的长度时必须将其转化为正数来求，而且求出的长度还要加上一位来放‘ - ’。得到integer的value值的长度后使用 getChars 方法来得到value的每一位上的字符。下面看看这个getChars方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static void getChars(int i, int index, char[] buf) &#123; int q, r; int charPos = index; char sign = 0; if (i &lt; 0) &#123; sign = &apos;-&apos;; i = -i; &#125; // 当i &gt;= 65536的时候每一次获取两位的char值。 while (i &gt;= 65536) &#123; q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); //使用移位操作快速计算出q*100，2^6+2^5+2^2=64+32+4=100. i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; &#125; // 当 i &lt;= 65536的时候每次只获取一位的char值 // assert(i &lt;= 65536, i); for (;;) &#123; q = (i * 52429) &gt;&gt;&gt; (16+3); //q/10,2^19=524288, (double)52429/(1&lt;&lt;19)=0.10000038146972656 r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; &#125; if (sign != 0) &#123; buf [--charPos] = sign; //如果是负数加上符号位 &#125; &#125;//--------------------------------------final static char [] DigitOnes = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &#125; ;//--------------------------------------final static char [] DigitTens = &#123; &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;0&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;2&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;3&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;4&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;5&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;6&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;7&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;8&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &apos;9&apos;, &#125; ; getChars方法也是十分的巧妙①在 i &gt;= 65536 的时候每次能够求出2位的char 值，求2位的char值时利用了两个数组 DigitOnes 和 DigitTens 就是在这两个数组的帮助下才能一次求出2位的char值下面就简单的说一下怎样利用这两个数组来分别求出个位和十位上的值的，假如现在得到两位数是 65，个位上是 5 要得到个位上的5，这时候不管十位是多少个位上一定是5，所以数组DigitOnes的 05，15，25，35，45，55，65，75，85，95位置上都是 5，这样不管是25，还是35 都能得到个位上的5。在来看看如何得到十位上的数，还是65，十位是6，所以DigitTens 的60，61，62，63，64，……69 位置上都是6。 ② q = (i * 52429) &gt;&gt;&gt; (16+3);这段代码其实就是q=i/10 ,其中 (double)52429/(1&lt;&lt;19)=0.10000038146972656也就是在int型的时候计算一个数的十分之1的精度是够的，可以看出jdk开发者的这种优化意识是非常强的。③(q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2) 这段等价于q100，因为 q2^6+q2^5+q2^2=q(64+32+4)=100q.这里为什么不直接使用q100，而要使用位移操作，因为其实q*100底层还是要进行位移操作的，直接使用位移操作效率更高，这也给我们编程带来启示。能够优化的时候一定要优化。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--ArrayDeque双端队列完全解析]]></title>
    <url>%2F2017%2F05%2F09%2FJava%E8%BF%9B%E9%98%B6-ArrayDeque%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayDeque的基本用法1234567891011121314151617181920212223public class DequeDemo &#123; public static void main(String[] args) &#123; int []arr=&#123;1,2,3,4,5,6,7,8&#125;; ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(); for(int i=0;i&lt;arr.length;i++) &#123; if((i&amp;1)==0) //如果i是偶数从队头加入，否则从队尾加入 aDeque.addFirst(arr[i]); else aDeque.addLast(arr[i]); &#125; while(!aDeque.isEmpty()) &#123; aDeque.pollFirst(); aDeque.pollLast();//此处不严谨但是由于arr的元素恰好是偶数个，本例中也不会出现问题。 &#125; &#125;&#125; 上面这段程序简单的演示了如果对双端队列的操作，下面给出上面代码的示意图： 上图是在执行完往双端队列加元素后，双端队列中元素的存储情况，由上图可以得出以下几点结论：①ArrayDeque 默认分配16个空间的数组。数组下标从0-15。②addFirst(arr[i]) 操作是将元素从数组的最后一个位置向前依次存放。③addLast(arr[i]) 操作是将元素从数组的第一个位置依次向后存放。 上面的图是分别在执行一次pollFirst() 和 pollLast() 后双端队列中的存储情况。由上图可知一下几点：①如果单独将addFirst(arr[i]) 和pollFirst() 结合使用的话，先进的元素会后出队，后进的元素反而先队，实现的是栈的功能。②如果单独将addLast(arr[i]) 和pollLast() 结合使用的话，先进的元素会后出队，后进的元素反而先队，实现的也是栈的功能。 再看下面的代码： 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; int []arr=&#123;1,2,3,4,5,6,7,8&#125;; ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(); //从双端队列的头部加元素 for(int i=0;i&lt;arr.length;i++) aDeque.addFirst(arr[i]); //从双端队列的尾部删元素 while(!aDeque.isEmpty()) aDeque.pollLast(); &#125;&#125; 上面代码中依次从队头加入元素，然后在队尾删除元素下面是示意图： 使用addFirst(arr[i]) 将元素全部加到双端队列中。 进行一次pollLast() 后队列中元素的情况。进行3次pollLast() 后队列中元素的情况。 由上可以得出以下几点：①如果单独将addFirst(arr[i]) 和pollLast() 结合使用的话，先进的元素会先出队，后进的元素会后出队，实现的是普通队列。②如果单独将addLast(arr[i]) 和pollFirst() 结合使用的话，先进的元素会先出队，后进的元素会后出队，实现的也是普通队列。 深入了解ArrayDeque下面从源码来看看ArrayDeque是如何实现上述功能的。 构造函数默认构造函数新建了一个大小为16的数组。1234public ArrayDeque() &#123; elements = (E[]) new Object[16]; //默认构造函数新建了一个大小为16的数组。 &#125; 用户初始化大小的构造函数。123public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125; 上面的构造函数中只用到 allocateElements(numElements) 下面看看allocateElements(numElements) 的源码 1234567891011121314151617private void allocateElements(int numElements) &#123; int initialCapacity = 8; if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) initialCapacity &gt;&gt;&gt;= 1;// 最大分配2 ^ 30 空间 &#125; elements = (E[]) new Object[initialCapacity];&#125; 上面的这段代码做一下几点说明：①当用户要求分配的数组大小小于8时，分配8个空间，当用户要求分配的数组大小为8时分配16个空间。②当用户要求分配的数组大小大于8时则分配大于用户需要内存的2的最小幂，比如用户需要分配的数组大小为21时，系统会分配大小为32的数组。③最大分配2 ^ 30 大小的数组。 传入容器的构造函数123456public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); //分配数组 addAll(c); // 将元素加入到 ArrayDeque中&#125; 下面看看 addAll(c) 的代码： 12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; //将元素全部加到ArrayDeque中。其中add 方法调用了addLast 后面会对addLast源码进行分析 &#125; public boolean add(E e) &#123; addLast(e); return true; &#125; 下面利用 ArrayDeque(Collection&lt;? extends E&gt; c) 这个构造器来实现一个简单的例子： 12345678910111213public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); //初始化的时候传入一个List的容器。 ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); while(!aDeque.isEmpty()) System.out.print(aDeque.pollLast()+&quot; &quot;); &#125; &#125; 上面代码中初始化时传入一个List的容器，下面示意图看看构造后的ArrayDeque是什么样的。 由上图可知：将list的元素加入到ArrayDeque中的时候是调用了addLast 方法，addList 方法是按顺序从前往后加入的。 addFirst12345678910public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); //如果加入的元素为null 抛出空指针异常。 elements[head = (head - 1) &amp; (elements.length - 1)] = e; //head值先减1，然后将元素放到head位置 if (head == tail) doubleCapacity(); //如果head == tail 将数组大小扩大一倍 &#125; 上面的tail 和 head到底是啥，还是画图来看看。由上图可知①addFirst 加一个元素时，head都会先减1，然后再放元素。head初始值为 0。② (head - 1) &amp; (elements.length - 1) 使head的值在【0， elements.length - 1】范围之内，同时可以循环利用数组里面的空间，head一直围着数组转圈。③如果tail==head 的时候，由上图可知数组中的元素已经满了，所以会将数组的扩大一倍。初始时tail=0。 addLast12345678public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; //将e的值放到tail位置，然后tail+1，如果数组满了扩容一倍。 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; 由上面的图可知 addLast 时操作 tail 在tail位置加入元素，如果数组已经满了就扩容一倍。 pollFirst123456789public E pollFirst() &#123; int h = head; E result = elements[h]; //将elements[h]赋值给result。 if (result == null) return null;//如果result 为null 直接返回 elements[h] = null; // 如果result不为null 将elements[h] 赋值为null head = (h + 1) &amp; (elements.length - 1);// head+1. return result; &#125; 下面是一个使用pollFirst() 的例子。 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); for(int i=0;i&lt;3;i++) aDeque.addFirst(arr[i]); //往双端队列中添加元素 while(!aDeque.isEmpty()) aDeque.pollFirst(); //使用pollFirst()删除。 &#125; &#125; 下面看看上面代码的流程图：添加完元素后的双端队列。执行一次pollFirst() 后。执行两次pollFirst()之后执行三次pollFirst()之后执行6次pollFirst()之后。通过上面的图就很好理解pollFirst() 的删除流程了。 pollLast12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); E result = elements[t]; //tail 先减1然后获取tail中的内容。 if (result == null) return null;//如果result 为null 直接返回 elements[t] = null;//否则将t位置的元素清空再返回result tail = t; return result; &#125; 还是利用上面的那段代码只不过将pollFirst（） 改为pollLast() 代码如下 1234567891011121314public class DequeDemo &#123; public static void main(String[] args) &#123; Integer []arr=&#123;1,2,3,4,5,6,7,8&#125;; List&lt;Integer&gt; list=Arrays.asList(arr); ArrayDeque&lt;Integer&gt; aDeque=new ArrayDeque&lt;Integer&gt;(list); for(int i=0;i&lt;3;i++) aDeque.addFirst(arr[i]); //添加元素 while(!aDeque.isEmpty()) aDeque.pollLast(); //删除元素 &#125; &#125; 依然上图：添加完元素的队列。执行一次pollLast() 后。执行8次pollLast() 后。执行9次pollLast() 后。由上面可以总结出：①每次pollLast()前tail先减1，然后再删除，tail指向的位置在元素的上一个位置。② pollLast() 也是绕着数组循环删除的。tail一直绕着数组循环转动。 removeFirst()12345678public E removeFirst() &#123; E x = pollFirst(); //调用pollFirst() if (x == null) throw new NoSuchElementException(); //当pollFirst()返回null抛出null 元素异常。 return x; &#125; 由上面代码可知其实removeFirst() 就是调用pollFirst() 不同之处在于在当pollFirst()返回null removeFirst() 抛出 null 元素异常。 removeLast()1234567public E removeLast() &#123; E x = pollLast(); //调用 pollLast() 当pollLast()返回null抛出null 元素异常。 if (x == null) throw new NoSuchElementException(); return x; &#125; 由上面代码可知其实removeLast() 就是调用pollLast() 不同之处在于在当pollLast()返回null removeLast() 抛出 null 元素异常。 add(E e)12345public boolean add(E e) &#123;//调用 addLast(e); 添加成功返回 true。 addLast(e); return true; &#125; remove()123public E remove() &#123; return removeFirst(); &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ArrayDeque</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java堆结构PriorityQueue完全解析]]></title>
    <url>%2F2017%2F05%2F04%2FJava%E5%A0%86%E7%BB%93%E6%9E%84PriorityQueue%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在堆排序这篇文章中千辛万苦的实现了堆的结构和排序，其实在Java 1.5版本后就提供了一个具备了小根堆性质的数据结构也就是优先队列PriorityQueue。下面详细了解一下PriorityQueue到底是如何实现小顶堆的，然后利用PriorityQueue实现大顶堆。 PriorityQueue的数据结构 PriorityQueue的逻辑结构是一棵完全二叉树，存储结构其实是一个数组。逻辑结构层次遍历的结果刚好是一个数组。 PriorityQueue的操作①add(E e) 和 offer(E e) 方法 add(E e) 和 offer(E e) 方法都是向PriorityQueue中加入一个元素，其中add（）其实调用了offer（）方法如下： 123public boolean add(E e) &#123; return offer(e); &#125; 下面主要看看offer（）方法的作用：如上图调用 offer（4）方法后，往堆中压入4然后从下往上调整堆为小顶堆。offer（）的代码实现： 1234567891011121314151617public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); //如果压入的元素为null 抛出异常 int i = size; if (i &gt;= queue.length) grow(i + 1); //如果数组的大小不够扩充 size = i + 1; if (i == 0) queue[0] = e; //如果只有一个元素之间放在堆顶 else siftUp(i, e); //否则调用siftUp函数从下往上调整堆。 return true; &#125; 对上面代码做几点说明：①优先队列中不能存放空元素。②压入元素后如果数组的大小不够会进行扩充，上面的queue其实就是一个默认初始值为11的数组（也可以赋初始值）。③offer元素的主要调整逻辑在 siftUp ( i, e )函数中。下面看看 siftUp(i, e) 函数到底是怎样实现的。 123456789101112private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; 上面的代码还是比较简明的，就是当前元素与父节点不断比较如果比父节点小就交换然后继续向上比较，否则停止比较的过程。 ② poll() 和 remove() 方法 poll 方法每次从 PriorityQueue 的头部删除一个节点，也就是从小顶堆的堆顶删除一个节点，而remove（）不仅可以删除头节点而且还可以用 remove(Object o) 来删除堆中的与给定对象相同的最先出现的对象。先看看poll（）方法。下面是poll（）之后堆的操作 删除元素后要对堆进行调整： 堆中每次删除只能删除头节点。也就是数组中的第一个节点。将最后一个节点替代头节点然后进行调整。如果左右节点中的最小节点比当前节点小就与左右节点的最小节点交换。直到当前节点无子节点，或者当前节点比左右节点小时停止交换。 poll（）方法的源码 123456789101112131415public E poll() &#123; if (size == 0) return null; //如果堆大小为0则返回null int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null;//如果堆中只有一个元素直接删除 if (s != 0) siftDown(0, x);//否则删除元素后对堆进行调整 return result; &#125; 看看 siftDown(0, x) 方法的源码： 1234567891011121314151617private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = key; &#125; siftDown（）方法就是从堆的第一个元素往下比较，如果比左右孩子节点的最小值小则与最小值交换，交换后继续向下比较，否则停止比较。remove（4）的过程图：先用堆的最后一个元素 5 代替4然后从5开始向下调整堆。这个过程和poll（）函数一样，只不过poll（）函数每次都是从堆顶开始。remove(Object o)的代码：123456789101112public boolean remove(Object o) &#123; int i = indexOf(o); //先在堆中找到o的位置 if (i == -1) return false; //如果不存在则返回false。 else &#123; removeAt(i); //否则删除数组中第i个位置的值，调整堆。 return true; &#125; &#125; removeAt(int i)的代码123456789101112131415161718private E removeAt(int i) &#123; assert i &gt;= 0 &amp;&amp; i &lt; size; modCount++; int s = --size; if (s == i) // removed last element queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved); if (queue[i] == moved) &#123; siftUp(i, moved); if (queue[i] != moved) return moved; &#125; &#125; return null; &#125; 使用PriorityQueue实现大顶堆PriorityQueue默认是一个小顶堆，然而可以通过传入自定义的Comparator函数来实现大顶堆。如下代码： 1234567 private static final int DEFAULT_INITIAL_CAPACITY = 11;PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;Integer&gt;(DEFAULT_INITIAL_CAPACITY, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125; &#125;); 实现了一个初始大小为11的大顶堆。这里只是简单的传入一个自定义的Comparator函数，就可以实现大顶堆了。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀树（Trie）原理及Java实现]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89%E5%8E%9F%E7%90%86%E5%8F%8AJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前缀树的结构Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树或键树，是一种多叉树结构。如下图： 上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质：①根节点不包含字符，除根节点外的每一个子节点都包含一个字符。②从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。③每个节点的所有子节点包含的字符互不相同。④从第一字符开始有连续重复的字符只占用一个节点，比如上面的to，和ten，中重复的单词t只占用了一个节点。 前缀树的应用1、前缀匹配2、字符串检索3、词频统计4、字符串排序 下面看看怎样使用前缀树来实现前缀匹配的。 前缀匹配了解了前缀树的结构后，就可以利用前缀树的性质来解决现实中的问题。比如说查找一个字符串数组中是否含有前缀单词，什么是前缀单词：上面的 in，就是 inn 的前缀单词。如果有十几万条单词，并且每个单词的长度都是5-10以内，这样必定存在大量重复的字符，因此利用前缀树来求解不仅速度快而且空间复杂度也比较好。①定义前缀树结构1234class Tries&#123; Boolean isTrie ; HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); &#125; 上面的 isTrie 用来标记单词是否遍历完。children表示该节点的子节点。如上面的t节点的子节点有o和e两个。 ②建立前缀树12345678910111213141516171819202122232425262728293031323334353637public static boolean insertNode(String str,Tries head)&#123; if(str==null||str.length()==0) return false; //如果插入的单词为null 或者单词长度为0直接返回false，false代表该单词不是前缀树中某个单词的前缀， //或者前缀树中某个单词是该单词的前缀。 char chs[]=str.toCharArray(); int i=0; Tries cur=head; //将字符串的每个字符插入到前缀树中 while(i&lt;chs.length) &#123; if(!cur.children.containsKey(chs[i])) &#123; cur.children.put(chs[i], new Tries()); //如果当前节点中的子树节点中不包含当前字符，新建一个子节点。 &#125; //否则复用该节点 cur=cur.children.get(chs[i]); if(cur.count==true) &#123; System.out.println(&quot; trie tree&quot;); return true; //判断前缀树中是否有字符串为当前字符串的前缀。 &#125; i++; &#125; cur.count=true; if(cur.children.size()&gt;0) &#123; System.out.println(&quot; trie tree&quot;); return true; //判断当前字符串是否是前缀树中某个字符的前缀。 &#125; return false;&#125; 前缀树的建立过程就是插入字符串的过程，同时在插入节点的时候可以判断插入的字符串是否是前缀树里面某个单词的前缀，或者前缀树中的某个单词是否是该单词的前缀。 ①先将字符串转换为字符数组，然后对每个字符进行处理，如果当前节点的子节点中包含有要处理的字符字节复用。否则新建一个子节点。②判断是否是前缀单词的时候，有两个步骤，首先要看该字符串是否是其他字符串的前缀，还有看其他字符串是否是当前字符串的前缀。 判断前缀单词的完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class isTrie &#123; public static void main(String[] args) &#123; Tries tries=new Tries(); String strs[]=&#123;&quot;abc&quot;,&quot;abd&quot;,&quot;b&quot;,&quot;abdc&quot;&#125;; for(int i=0;i&lt;strs.length;i++) insertNode(strs[i], tries); &#125;public static boolean insertNode(String str,Tries head) &#123; if(str==null||str.length()==0) return false; char chs[]=str.toCharArray(); int i=0; Tries cur=head; while(i&lt;chs.length) &#123; if(!cur.children.containsKey(chs[i])) &#123; cur.children.put(chs[i], new Tries()); &#125; cur=cur.children.get(chs[i]); if(cur.count==true) &#123; System.out.println(&quot; trie tree&quot;); return true; &#125; i++; &#125; cur.count=true; if(cur.children.size()&gt;0) &#123; System.out.println(&quot; trie tree&quot;); return true; &#125; return false; &#125;&#125;class Tries&#123; boolean isTrie; HashMap&lt;Character, Tries&gt; children=new HashMap&lt;Character, Tries&gt;(); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>前缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典算法--最大存水量问题]]></title>
    <url>%2F2017%2F04%2F29%2F%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%98%E6%B0%B4%E9%87%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：给出一个数组代表围柱的高度，求能围柱的最大的水量，例如数组{ 5，2，3，2，4 }，最大水量为5。 如下图：黄色部分为围柱，绿色部分是能够围住的水，图中围柱的高度依次为 5，2，3，2，4最多能围住的水量是5。 思路：求出每个柱子上面能够存多少水，然后将每根柱子的存水量相加便能得到总的存水量，为求出每根柱子上能够存多少水，就要求出每根柱子左边最高的和右边最高柱子，然后用两者的最小值减去当前柱子的高度。 例如图中从左到右第二根柱子的高度为2，它左边最高柱子的值为5，右边最高柱子的值为4，因此它的最大存水量为 Min（4，5）-2=2。 解法1利用上面思路，从左到右遍历每根柱子，遍历的时候求出每根柱子左边最高和右边最高柱子的值，然后利用s两者的最小值减去当前柱子的高度就行了。时间复杂度O（n^2）,空间复杂度O（1）。 123456789101112131415161718192021222324public static int water1(int []arr) &#123; int water=0; //water 用于保存最大存水量 if(arr==null||arr.length&lt;=1) return 0; //如果只有一根柱子围不住水。 int leftLargest=0,rightLargest=0; //leftLargest,rightLargest 分别用于保存遍过程中，当前元素左边最大值，和右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=0; rightLargest=0; for(int j=0;j&lt;i;j++) leftLargest=Math.max(leftLargest,arr[j]); //先求出当前元素左边最大值。 for(int j=arr.length-1;j&gt;i;j--) rightLargest=Math.max(rightLargest, arr[j]); //最求出当前元素右边最大值 water+=Math.min(leftLargest, rightLargest)&gt;arr[i]?Math.min(leftLargest, rightLargest)-arr[i]:0;//左边最大值和右边最大值的最小值与当前元素比较如果小于当前元素，则当前元素上水量为0，围不住水，如果大于当前元素，则减去当前元素得到存水量。 &#125; return water; &#125; 注意：① 如果当前柱子大于它左右最大值的任何一个是存不了水的。 解法2分析上面的算法发现算法的时间复杂度为O（n^2）的原因是对于每个元素都要从左到右，和从右到最左遍历其两边最大值，假如使用两个数组 left[ ] , right[ ]来保存每个元素左边最大值，右边最大值的话，这样就不用每次都遍历了，因此时间复杂度可以减少到O（n），但空间复杂度为O（n），典型的空间换时间算法。如下图：对于数组{ 5, 2 , 6 , 2 , 4 }它的左右数组如下左数组：右数组 1234567891011121314151617181920212223242526272829public static int water1(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int leftLargest=0,rightLargest=0; int left[]=new int[arr.length]; //left 数组中保存每个元素左边的最大值，left[i]，表示数组中第i个元素的左边最大值。 int right[]=new int[arr.length]; //right数组中保存每个元素左边的最大值，right[i]，表示数组中第i个元素的右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=Math.max(leftLargest,arr[i]); left[i]=leftLargest; &#125; //先遍历一次找出每个元素左边最大值。 for(int i=arr.length-1;i&gt;=0;i--) &#123; rightLargest=Math.max(rightLargest,arr[i]); right[i]=rightLargest; &#125; //遍历找到每个元素右边最大值。 for(int i=0;i&lt;arr.length;i++) &#123; water+=Math.min(left[i],right[i])&gt;arr[i]?Math.min(left[i],right[i])-arr[i]:0; &#125; //利用当前元素的左边最大值和右边最大值求得存水量。 return water; &#125; 上面算法的流程：①从左到右遍历一次求出每个元素左边的最大值，保存在 left 数组中。②从右到左遍历一次求出每个元素右边的最大值，保存在right数组中。③最后一次遍历求出每个元素（每根柱子）的存水量。 改进解法2 ：分析上面算法发现其实没有必要使用 left 数组，因为当从左到右遍历求存水量的过程中可以利用一个变量来保存当前元素左边的最大值。代码如下 12345678910111213141516171819202122public static int water1(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int leftLargest=0,rightLargest=0; int right[]=new int[arr.length]; //只用一个右数组来保存从右到左的最大值。 for(int i=arr.length-1;i&gt;=0;i--) &#123; rightLargest=Math.max(rightLargest,arr[i]); right[i]=rightLargest; &#125; for(int i=0;i&lt;arr.length;i++) &#123; leftLargest=Math.max(leftLargest, arr[i]); //leftLargest 保存当前元素左边的最大值。 water+=Math.min(leftLargest,right[i])&gt;arr[i]?Math.min(leftLargest,right[i])-arr[i]:0; &#125; return water; &#125; 解法3能不能在时间复杂度O（n），空间复杂度O（1）的情况下来完成存水量的问题，答案是肯定的，用几幅图来描述一下解法3的过程。数组为 { 5，2，3，2，4 }。 ①上面左右两边的黄色块分别表示当前元素左边最大值和右边最大值。 ②left ，right分别代表从左到右移动和从右到左移动的指针。 ③如果当前元素的左边最大值比右边最大值小，则left指针向右移动，否则right指针向左移动。 ④这种左右指针移动的目的是为了保证所求的左右最大值一定是当前元素的左右最大值。 1234567891011121314151617181920212223242526public static int water3(int []arr) &#123; int water=0; if(arr==null||arr.length&lt;=1) return 0; int largestLeft=0,largestRight=0; //分别保存左右两边最大值 int left=0,right=arr.length-1; while(left&lt;right) &#123; largestLeft=Math.max(arr[left], largestLeft); largestRight=Math.max(arr[right], largestRight); //获得左右两边最大值 if(largestLeft&gt;largestRight) &#123; //如果左边最大值大于右边则右指针向移动 water+=largestRight-arr[right--]; &#125; else &#123; //否则左指针向右移动 water+=largestLeft-arr[left++]; &#125; &#125; return water; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最大存水量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试面试算法经典--最长括号匹配]]></title>
    <url>%2F2017%2F04%2F27%2F%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E7%BB%8F%E5%85%B8-%E6%9C%80%E9%95%BF%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在求最长括号匹配之前先看看括号下面这个问题： 括号匹配“ {（）}”这种是括号匹配，而 “{ ] ] { ” 这种就不是括号匹配。判断一个给定的括号字符串是否是匹配的。对于括号匹配这类的问题可以使用 Stack来处理：1 . 当碰到”( [ { “这些左括号就进栈。2 . 如果碰到“) ] }”这些右括号时，如果栈为空，则肯定不匹配，返回false。如果栈不为空，则出栈比较两个括号是否匹配不匹配返回 false 。3 . 如果遍历完整个括号串后栈为空返回true，否则返回false。 例：” ( { } ) [ ] “的匹配过程如下： ①颜色相同的表示同一类型的左右括号。 ②碰到两个左括号将它们入栈。 ③碰到右括号时出栈比较，如果相同出栈，不同直接返回false。 ④匹配完后栈为 null 返回 true，否则返回 false。12345678910111213141516171819202122232425262728293031323334353637public boolean isMatch(String str) &#123; if(str==null||str.length()==0) return false; //如果给出的字符串是null 或者长度为0返回false。 char chs[]=str.toCharArray(); Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); int i=0; String left=&quot;([&#123;&quot;; //用left保存左括号的类型，便于比较。 String right=&quot;)]&#125;&quot;; //用right 保存右括号的类型，便于比较。 while(i&lt;chs.length) &#123; if(left.contains(chs[i]+&quot;&quot;)) &#123; //如果是左括号，加入栈中 stack.push(chs[i]); &#125; else &#123; //如果是右括号，如果栈为null 返回false，否则比较栈顶元素与当前元素是否匹配。 if(stack.isEmpty()) &#123; return false; &#125; else &#123; char topchar=stack.pop(); if(left.indexOf(topchar)!=right.indexOf(chs[i])) //如果左右括号不匹配返回false。 return false; &#125; &#125; i++; &#125; return stack.isEmpty(); //如果栈为空，则返回 true，否则返回 false。 &#125; 最长括号匹配求一个括号串的最长括号子串的长度，如 “ ) ( ( ) ( ) ”的最长子串为“ ( ) ( ) ”长度为4。 方法1（暴力法 时间复杂度O（n^2）,空间复杂度O（n）） 用二重循环遍历每一个子串，子串是括号匹配的获得子串的长度，使用一个max_len 保存最大括号匹配子串的长度。优点：当左右括号的类型不唯一时也可以判断，缺点：时间复杂度大。 代码 1234567891011121314151617181920212223public static int longestMatch(String str) &#123; if(str==null||str.length()==0) return 0; int max_len=0; for(int i=0;i&lt;str.length()-1;i++) &#123; for(int j=i+1;j&lt;str.length();j++) &#123; String subString=str.substring(i, j+1); //遍历每一个子串，如果子串是括号匹配的，更新最大值。 //BracketsMatch.isMatch(subString)就是上面括号匹配方法。 if(BracketsMatch.isMatch(subString)) &#123; max_len=Math.max(max_len, j-i+1); &#125; &#125; &#125; return max_len; &#125; 方法2（ 时间复杂度O（n）,空间复杂度O（n）） 利用栈来保存括号的下标信息，并用变量 last 来保存不是匹配括号的最后一个下标，开始时 last=-1，如）（）（）），开始时 last=-1 ，当碰到左括号时，入栈，碰到右括号时如果栈为空则 last=当前有括号的下标，否则出栈，如果出栈后栈为空，则长度为 当前下标- last 。否则为当前下标- 栈的下一个元素。 1234567891011121314151617181920212223242526272829303132public static int longestMatch(String str) &#123; if(str==null||str.length()==0) return 0; char chs[]=str.toCharArray(); Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); //注意这种方法只能判断一种类型的左右括号，不能同时判断两种及以上的左右括号。 int i=0,last=-1,max_len=0; while(i&lt;chs.length) &#123; if(chs[i]==&apos;(&apos;) &#123; stack.push(i); &#125; else &#123; if(stack.isEmpty()) &#123; last=i; &#125; else &#123; stack.pop(); if(stack.isEmpty()) max_len=Math.max(max_len, i-last); else &#123; max_len=Math.max(max_len, i-stack.peek()); &#125; &#125; &#125; i++; &#125; return max_len; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>括号匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶--深入解析hashmap]]></title>
    <url>%2F2017%2F04%2F22%2FJava%E8%BF%9B%E9%98%B6-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90hashmap%2F</url>
    <content type="text"><![CDATA[HashMap原理先以一个简单的例子来理解hashmap的原理。在Java中先随机产生一个大小为20的数组如下： hash表的大小为7，将上面数组的元素，按mod 7分类如下图： 将这些点插入到hashmap中（简单hashmap）后如下图： 由上图可知：① hashmap是用链地址法进行处理，多个key 对应于表中的一个索引位置的时候进行链地址处理，hashmap其实就是一个数组+链表的形式。 ② 当有多个key的值相同时，hashmap中只保存具有相同key的一个节点，也就是说相同key的节点会进行覆盖。 ③在hashmap中查找一个值，需要两次定位，先找到元素在数组的位置的链表上，然后在链表上查找，在HashMap中的第一次定位是由hash值确定的，第二次定位由key和hash值确定。 ④节点在找到所在的链后，插入链中是采用的是头插法，也就是新节点都插在链表的头部。 ⑤在hashmap中上图左边绿色的数组中也存放元素，新节点都是放在左边的table中的，这个在上图中为了形象的表现链表形式而没有使用。 HashMap上面只是简单的模拟了hashmap 真实的hashmap的基本思想和上面是一样的不过更加复杂。HashMap中的一个节点是一个Entity 类如下图： Entry是HashMap的内部类 包含四个值（next，key，value，hash），其中next是一个指向 Entry的指针，key相当于上面节点的值 value对应要保存的值，hash值由key产生，hashmap中要找到某个元素，需要根据hash值来求得对应数组中的位置，然后在由key来在链表中找Entry的位置。HashMap中的一切操作都是以Entry为基础进行的。HashMap的重点在于如何处理Entry。因此HashMap中的操作大部分都是调用Entry中的方法。可以说HashMap类本身只是提供了一个数组，和对Entry类中方法的一些封装。 下面从源码方面对 HashMap进行解析： ①HashMap的继承关系123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 从上面可以看到HashMap继承了AbstractMap , 并且实现了Cloneable, Serializable 接口。 ②HashMap的构造函数下面的代码都是经过简化处理的代码，基本流程不变只是为了更好的理解修改和删除了一部分内容 1234567891011121314151617181920public HashMap(int initialCapacity, float loadFactor) &#123;/*initialCapacity 初始化hashmap中table表的大小，前面的图中左边绿色部分的数组就是table。loadFactor填装因子。*/ if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); //如果初始化大小小于0，抛出异常 if (initialCapacity &gt; 2^30) initialCapacity = 2^30; //HashMap 中table的最大值为2^30。 /* 生成一个比initialCapacity小的最大的2的n次方的值，这个值就是table的大小。table就是一个Entry类型的数组。 */ int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; table = new Entry[capacity];//新建一个Entry类型的数组，就是前面图中左边的数组。不过数组的元素是Entry类型的。 &#125; 上面的代码要做几点说明： ①填装因子:loadFactor 表示填装因子的大小，简单的介绍一下填装因子：假设数组大小为20，每个放到数组中的元素mod 17，所有元素取模后放的位置是（0–16） 此时填装因子的大小为 17/20 ,装填因子就为0.85啦，你装填因子越小，说明你备用的内存空间越多，装填因子的选定，可以影响冲突的产生，装填因子越小，冲突越小。 ②HashMap初始化过程就是新建一个大小为capacity，类型为Entry的数组，Entry上面已经介绍过这个类，包含一个指针一个key，一个value，和一个hash。capacity是2的次幂，至于为什么是2的次幂后面会有介绍的。 下面是另外两个构造函数123456789 public HashMap(int initialCapacity) &#123; HashMap(initialCapacity, 0.75); //调用了上面的构造函数，只不过使用了默认的填装因子0.75 &#125;public HashMap() &#123; HashMap(16, 0.75); //生成一个table大小为16，填装因子0.75的HashMap &#125; ③由上可知如果用户直接使用HashMap（）构造函数来new一个HashMap 会生成一个大小为16，填装因子为0.75的 HashMap。 ③HashMap中的put（key，value）函数还是先上源码 12345678910111213141516171819202122232425public V put(K key, V value) &#123; if (key == null) return putForNullKey(value);/*如果key为null则调用 putForNullKey(value) 函数 这个函数先在table[0]这条链上找有没有key 为null的元素如果有就覆盖，如果没有就新建一个new一个key为null，value=value hash=0，的Entry放在table[0]。*/ int hash = hash(key);//获得key的hash值 int i = indexFor(hash, table.length);//由hash值确定放在table表中的那一条链上。类似于取模后放在数组中的哪个位置。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; //如果链上原来有一个hash值相同，且key相同的则用新的value值进行覆盖。 &#125; &#125;//否则利用hash，key，value，new一个Entry对象插入到链表中。 modCount++; addEntry(hash, key, value, i); return null; &#125; 对上面代码做几点说明： ① HashMap中的key可以为 null ，此时hash=0，为什么key可以为null，因为HashMap中放的元素是Entry，而Entry包含了4个值（key，value，hash，next），key为 null 时不影响Entry映射到HashMap中。 ②hash(key)，产生一个正整数，这个整数与key相关。这个hash（key）函数比较关键，后面会进行说明。 ③用户插入的（key，value）对不是直接放到HashMap中的，而是用（key，value）以及后面由key value产生的hash，new一个Entry对象后再插入到HashMap中的。 ④如果对应的链上有一个hash值个key相同的Entry则覆盖value值，不new Entry对象，如果没有会先new 一个对象在将其插到对应的链上。（其中可能会涉及到扩充HashMap）。 下面看看hash（key）函数 123456789final int hash(Object k) &#123; int h = 0; h ^= k.hashCode(); //hashCode 返回一个整数值，这个值跟对象有关，不同对象的hashCode值一般不同。 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; hash函数的作用是使hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 ④HashMap中的get(Object key)函数上源码 123456789101112131415161718192021222324252627282930public V get(Object key) &#123; if (key == null) return getForNullKey();//如果key==null则在table[0]这条链上找，如果找到返回value值，否则返回null ，因为key==null的都是放在table[0]这条链上的。 Entry&lt;K,V&gt; entry = getEntry(key);// getEntry(key)先key的hash值找到在数组的哪条链上，然后在链上查找key相同的如果没找到返回null //如果找到了返回Entry的value值。 return null == entry ? null : entry.getValue(); &#125;private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 上面代码的几点说明 ① 通过key来链表中查找元素包括两个过程，先由hash找到链（hash由key产生，不同的key可能产生相同的hash值，相同的hash值放在同一条链上），再用key在链上找。 ② 如果key为null则只在table[0]和其链上查找，因为key为null都放在table[0]及其链上了。 ③因为在HashMap中查找到的是Entry对象，返回的值是Entry对象的value值。 重点Entry类其实理解HashMap最重要的在于理解Entry类，Entry类相当于链表中的一个节点，是HashMap操作的基础。下面主要从Entry类的几个方法来理解Entry类和HashMap的关系。 ①Entry中的addEntry( hash, key, value, bucketIndex)函数在HashMap中调用put（key，value）时，如果（key，value）是首次加入到HashMap中，就会调用addEntry( hash, key, value, bucketIndex)函数，将其加入到table表对应的位置中（注意是table中，不是后面的链中，首次加入的元素都是采用的头插法）。下面是源码： 12345678910111213141516171819202122void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); //如果size的值超过了threshold，将table扩容两倍 hash = (null != key) ? hash(key) : 0; //如果key为null则hash=0，否则hash函数利用key来产生hash值。 bucketIndex = indexFor(hash, table.length); //bucketIndex就相当于取模后对应的table表中的哪个位置。 &#125; //如果不存在容量不够问题则直接新建一个Entry对象。 createEntry(hash, key, value, bucketIndex); &#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //获得原来首位的Entry对象 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); //将新建的Entry对象放在链表的首位，然后用next指向原来放在首位的对象。也就是头插。 size++; &#125; 上面代码的几点说明：①bucketIndex是由hash取模后对应于table表中的哪个位置。indexFor(hash, table.length)其实是一个取模函数。它的实现很简单 hash&amp; (length-1)，就是用hash值与上table表的长度减1。 ②并不是对每一个（key，value）对都产生一个Entry对象，只是（key，value）对首次放到HashMap中时，或者HashMap中没有相同的key时，才产生一个Entry对象，否则如果有相同的key则会直接将value值赋个Entry的value。 ③新产生的Entry都是放在了table中，也就是链表的首位，采用链表的头插法。 ②HashMap中的keySet()函数作用：返回HashMap中key的集合。keySet是HashMap中的内部类： 12345678910111213141516171819202122232425262728public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); //如果keyset为null就产生一个keyset对象。 &#125; private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); //newKeyIterator迭代器用于遍历key。 &#125; public int size() &#123; return size; //返回keyset的大小 &#125; public boolean contains(Object o) &#123; return containsKey(o); //是否包含某个key &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; //移除某个key的Entry。 &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; keySet是用来遍历整个HashMap的，因此是十分重要的，下面做几点说明。①keyset中有一个迭代器可以迭代的获取下一个key的值，通过key的值就可以获得Entry对象了。 ②对应key的迭代遍历是table表中由左向右，由上向下进行的，也就是先遍历table[0]这条链上的，然后遍历table[1]这条链上的依次往下进行。 ③newKeyIterator具体实现这里就不多介绍，只要知道上面的功能怎么实现就可以了。 下面是利用keyset来实现遍历HashMap的例子： 1234567891011121314HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;Integer, Integer&gt;(); for(int i=0;i&lt;20;i++)&#123; hashMap.put(i, i+1);&#125;//新建一个hashmap往里面放入20个（key，value）对。Iterator&lt;Integer&gt; iterator= (Iterator&lt;Integer&gt;) hashMap.keySet().iterator();//获得keyset的iterator，进行遍历整个hashmap。while(iterator.hasNext())&#123; Integer key=(Integer) iterator.next(); Integer val=(Integer)hashMap.get(key); System.out.println(key+&quot;: &quot;+val);&#125; ②HashMap中的entrySet()函数作用：返回HashMap中Entry的集合。对于entrySet这里就不上源码了，举一个使用entrySet遍历HashMap的例子： 123456789101112HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;Integer, Integer&gt;(); for(int i=0;i&lt;20;i++) &#123; hashMap.put(i, i+1); &#125; Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator=hashMap.entrySet().iterator(); while(iterator.hasNext()) &#123; Entry entry= iterator.next(); System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue()); &#125; 使用entrySet()函数遍历比keySet()函数遍历快，因为keySet()函数是先通过entrySet()求出key然后在通过key来遍历获得Entry的，所以速度比entrySet()慢很多。参考文献：①http://blog.csdn.net/jiary5201314/article/details/51439982②http://www.cnblogs.com/chenssy/p/3521565.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
</search>
